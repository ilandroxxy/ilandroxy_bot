
# region Домашка: ******************************************************************************



# endregion Домашка:  ******************************************************************************



# region Урок:  ******************************************************************************


# region (№ 5446) (В. Шубинкин)
'''
# Автомат получает на вход номер банковской карты (число N из 16 цифр) и строит по нему контрольное число S следующим образом (вариант алгоритма Лу́на):
# 1) Цифры числа нумеруются справа налево, начиная с нуля.
# 2) Цифры, стоящие на нечётных позициях, увеличиваются в два раза. Если при этом получается двузначное число, его цифры складываются.
# 3) Число S вычисляется как сумма всех цифр на чётных позициях и преобразованных цифр на нечётных позициях.
# Например, для числа 4096 8308 0309 8323 сумма цифр на чётных позициях (с конца) 3+3+9+3+8+3+6+0=35, сумма преобразованных цифр на нечётных позициях 4+7+0+0+0+7+9+8=35. Общая сумма S = 70.
# Найдите наименьший номер банковской карты N, для которого результатом работы алгоритма будет число 30.
# В ответе укажите остаток от деления найденного числа N на 10**8.


s = '0123456789'
for a in '123456789':
    for b in s:
        for c in s:
            for d in s:
                for e in s:
                    for f in s:
                        for g in s:
                            for h in s:
                                for z in s:
                                    for j in s:
                                        for k in s:
                                            for l in s:
                                                for m in s:
                                                    for n in s:
                                                        for o in s:
                                                            for p in s:
                                                                temp = a + b + c + d + e + f + g + h + z + j + k + l + m + n + o + p
                                                                M = [int(i) for i in temp]
                                                                M.reverse()
                                                                for i in range(1, len(M), 2):
                                                                    x = M[i] * 2
                                                                    if x >= 10:
                                                                        M[i] = (x // 10) + (x % 10)
                                                                    else:
                                                                        M[i] = x
                                                                if sum(M) == 30:
                                                                    print(temp, M, sum(M))
                                                                    print(int(temp) % 10**8)
                                                                    exit()
'''
# Ответ: 1899
# endregion (№ 5446) (В. Шубинкин)


# region (№ 5440) (А. Сардарян)
'''
# На вход алгоритма подаётся два натуральных числа N и M.
# Алгоритм строит по ним новое число R следующим образом.
# 1) Вычисляется число S_N как квадрат суммы цифр двоичной записи числа N.
# 2) Вычисляется число S_M как квадрат суммы цифр двоичной записи числа M.
# 3) Результат R вычисляется как S_N – S_M.
# Укажите минимальную сумму чисел N и M, при которых получается R = 33.

mini = 9999
for n in range(1, 1000):
    for m in range(1, 1000):
        s_n = sum([int(i) for i in bin(n)[2:]]) ** 2
        s_m = sum([int(i) for i in bin(m)[2:]]) ** 2

        r = s_n - s_m
        if r == 33:
            if mini > n + m:
                mini = n + m
                print(mini)
'''
# Ответ: 142
# endregion (№ 5440) (А. Сардарян)


# region (№ 4045)
'''
# Алгоритм получает на вход натуральное число N > 1 и строит по нему новое число R следующим образом:
# 1) Если исходное число кратно 2, оно делится на 2, иначе из него вычитается 1.
# 2) Если полученное на предыдущем шаге число кратно 5, оно делится на 5, иначе из него вычитается 1.
# 3) Если полученное на предыдущем шаге число кратно 7, оно делится на 7, иначе из него вычитается 1.
# 4) Число, полученное на шаге 3, считается результатом работы алгоритма.
# Сколько существует различных натуральных чисел N, при обработке которых получится R = 6?
count = 0
for n in range(1, 1000000):
    if n % 2 == 0:
        n //= 2
    else:
        n -= 1

    if n % 5 == 0:
        n //= 5
    else:
        n -= 1

    if n % 7 == 0:
        n //= 7
    else:
        n -= 1

    if n == 6:
        count += 1
print(count)
'''
# Ответ: 3
# endregion (№ 4045)


# region (№ 5439) (А. Сардарян)
'''
# На вход алгоритма подаётся четырёхзначное натуральное число N. Алгоритм строит по нему новое число R следующим образом.
# 1) Если число N четное, то цифры этого числа сортируются в порядке убывания, затем полученное число делится на 2 нацело (остаток отбрасывается).
# Полученное значение является числом R.
# Пример: N = 1488 => R = 8841//2 = 4420.
# 2) Если число N нечетное, то цифры этого числа сортируются в порядке возрастания, затем полученное число умножается на 2.
# Полученное значение является числом R.
# Пример: N = 3807 => R = 378·2 = 756.
# Укажите наименьшее число R, которое больше соответствующего исходного числа N на 1.

RES = []
RESULT = set()
for n in range(1000, 10000):
    if n % 2 == 0:
        M = [int(i) for i in str(n)]
        M = sorted(M, reverse=True)
        # M.sort()
        # M.reverse()
        M = [str(i) for i in M]
        R = int(''.join(M)) // 2
    else:
        M = [int(i) for i in str(n)]
        M.sort()
        M = [str(i) for i in M]
        R = int(''.join(M)) * 2

    if R == n + 1:
        print(R)
        RES.append(R)
        RESULT.add(R)
print(min(RES))
print(min(RESULT))
'''
# Ответ: 2105
# endregion (№ 5439) (А. Сардарян)


# region (№ 4222) (В.Н. Шубинкин)
'''
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом:
# 1) Строится шестнадцатеричная запись числа N // 2, где "//" - операция деления нацело.
# 2) К этой записи дописывается ещё три разряда по следующему правилу: если N не делится на 4, то слева к нему приписывается "F", а справа - "A0".
# В противном случае слева приписывается "15", а справа "C".
# Например, N = 4_10 => 2_16 => 152C_16 = 5420_10 = R.
# Полученная таким образом запись (в ней на три разряда больше, чем в записи исходного числа N) является шестнадцатеричной записью искомого числа R.
# Укажите наибольшее число N, для которого результат работы алгоритма меньше 65536. В ответ запишите это число в десятичной системе счисления.

for n in range(1, 1000):
    x = n // 2
    M = []
    while x > 0:
        M.append(x % 16)
        x //= 16
    M.reverse()
    M = [str(i) for i in M]
    R = ''.join(M)

    if n % 4 != 0:
        R = 'F' + R + 'A0'
    else:
        R = '15' + R + 'C'

    res = int(R, 16)

    if res < 65536:
        print(n, res)
'''
# Ответ: 4222
# endregion (№ 4222) (В.Н. Шубинкин)



# endregion Урок:  ******************************************************************************


# todo: Слава = [2, 5, 6, 8, 9, 12, 14+, 15, 16, 17, 23, 24+, 25.1], на следующем уроке: Разобрать 17 номер - подробно
# todo: сложности 5, 8, 17, 24, 25