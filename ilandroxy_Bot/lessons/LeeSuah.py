# region Домашка: ************************************************************


# endregion Домашка: ************************************************************

# region Урок: ************************************************************

# Разобрать Тип 24 №61370 Олеся - done
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите максимальное количество идущих подряд символов, среди которых ровно по одному разу встречаются буквы A и B.
'''
s = open("24.txt").readline()
s = s.replace('A', 'A ').replace('B', 'B ').split(' ')
print(s)
maxi = 0
for i in range(len(s) - 2):
    r = ''.join(s[i:i+3])[:-1]
    # r = s[i] + s[i + 1] + s[i + 2][:-1]
    # 'RMDWGZYEFQURB', 'KQNNRWA', 'VFOOGA'  - справа убираем A
    # 'RMDWGZYEFQURBKQNNRWAVFOOG'
    # if r.count('A') == 1 and r.count('B') == 1:
    if 'A' in r and 'B' in r:
        maxi = max(maxi, len(r))
print(maxi)
'''
# Ответ: 182

# Разобрать Тип 24 №63040 Олеся - done
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите максимальное количество идущих подряд символов, среди которых каждая из букв A и B
# встречается не более двух раз.
'''
s = open("24.txt").readline()
s = s.replace('A', 'A ').replace('B', 'B ').split(' ')
maxi = 0
for i in range(len(s) - 4):
    r = ''.join(s[i:i+5])[:-1]
    # 'LRKMXZPVSKUIB', 'UUGORTGGXWB', 'TYRHYOQGRNEA', 'IKA', 'VMQFOHHVZKWEXCNTCDKJWQVTVXZWRKA'
    if r.count('A') == 2 and r.count('B') == 2:
        maxi = max(maxi, len(r))
print(maxi)
'''
# Ответ: 222


# Разобрать Тип 24 №63073 Олеся - done
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите максимальное количество идущих подряд символов, среди которых каждая из букв C и D встречается
# не более двух раз.
'''
s = open("24.txt").readline()
s = s.replace('C', 'C ').replace('D', 'D ').split(' ')
maxi = 0
for i in range(len(s) - 4):
    r = ''.join(s[i:i+5])[:-1]
    if r.count('C') == 2 and r.count('D') == 2:
        maxi = max(maxi, len(r))
print(maxi)
'''
# Ответ: 253


# ТЕОРИЯ:
'''
# Адрес сети = IP-адрес узла & Маска
# Маска всегда имеет длину 32 бита и вид: "11111...0000"

# IP состоит из 4 чисел на каждое из которых выделяется по 1 байту (8 битов)
# Таким образом числа имеют диапазон от 0 (00000000) до 255 (11111111)

# Представление IP-адреса узла 102.9.140.219 в двоичном виде:
print('.'.join([bin(int(x))[2:].zfill(8) for x in '102.9.140.219'.split('.')]))
# 01100110.00001001.10001100.11011011


# Тип 13 №7208
# По заданным IP-адресу узла и маске определите адрес сети.
# IP-адрес узла: 102.9.140.219
# Маска: 255.255.192.0

knot = '.'.join([bin(int(x))[2:].zfill(8) for x in '102.9.140.219'.split('.')])  # 01100110.00001001.10001100.11011011
mask = '.'.join([bin(int(x))[2:].zfill(8) for x in '255.255.192.0'.split('.')])  # 11111111.11111111.11000000.00000000

address = ''
for i in range(len(knot)):
    if knot[i] == '1' and mask[i] == '1':
        address += '1'
    elif knot[i] == '.' and mask[i] == '.':
        address += '.'
    else:
        address += '0'
print(address)  # 01100110.00001001.10000000.00000000

ip_address = [int(x, 2) for x in address.split('.')]
print(ip_address)

# 01100110.00001001.10001100.11011011
# 11111111.11111111.11000000.00000000 - маска всегда имеет длину 32 бита и вид: "11111...0000"
# 01100110.00001001.10000000.00000000


# Удобное решение:
from ipaddress import *
net = ip_network('102.9.140.219/255.255.192.0', strict=0)
print(net)  # 102.9.128.0/18  # 18 - кол-во единиц в маске сети 

# Параметр strict=0 в функции ip_network указывает, что адреса в пределах данной сети можно использовать
# для широковещания или для анализа входных данных. Когда strict=0, это означает, что сеть может включать адреса,
# которые обычно не являются допустимыми для хостов, такие как адреса сетевого и широковещательного протоколов.
# Таким образом, при установке strict=0, вы позволяете использовать все адреса в сети,
# а не только те, которые доступны для хостов.
'''
# Ответ: EABF


# Тип 13 №5315
# По заданным IP-адресу узла и маске определите адрес сети.
# IP-адрес узла: 248.137.249.32
# Маска: 255.255.252.0
'''
from ipaddress import *
net = ip_network('248.137.249.32/255.255.252.0', 0)
print(net)  # 248.137.248.0/22
#           '255.255.252.0'  '8.8.6.0)
'''
# Ответ: CECH


# Тип 13 №9196
# Для узла с IP-адресом 235.116.177.140 адрес сети равен 235.116.160.0.
# Чему равен третий слева байт маски? Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'235.116.177.140/{mask}', 0)
    print(net)  # 235.116.160.0/19
'''
# Ответ: 160


# Тип 13 №13542
# Для узла с IP-адресом 136.128.196.48 адрес сети равен 136.128.192.0.
# Чему равно наибольшее возможное значение третьего слева байта маски?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'136.128.196.48/{mask}', 0)
    print(net, net.netmask)

    # 136.128.192.0/18 255.255.192.0
    # 136.128.192.0/19 255.255.224.0
    # 136.128.192.0/20 255.255.240.0
    # 136.128.192.0/21 255.255.248.0
'''
# Ответ: 248


# Тип 13 №10502
# Для узла с IP-адресом 119.167.58.77 адрес сети равен 119.167.32.0.
# Чему равно наименьшее возможное значение третьего слева байта маски? Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'119.167.58.77/{mask}', 0)
    print(net, net.netmask)
    
    # 119.167.32.0/19 255.255.224.0
 '''
# Ответ: 224


# Тип 13 №11308
# Для узла с IP-адресом 203.155.196.98 адрес сети равен 203.155.192.0.
# Найдите наибольшее возможное количество единиц в двоичной записи маски подсети.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'203.155.196.98/{mask}', 0)
    print(net, net.netmask)

    # 203.155.192.0/18 255.255.192.0
    # 203.155.192.0/19 255.255.224.0
    # 203.155.192.0/20 255.255.240.0
    # 203.155.192.0/21 255.255.248.0
'''
# Ответ: 21


# Тип 13 №14698
# Для узла с IP-адресом 93.138.161.94 адрес сети равен 93.138.160.0.
# Какое наибольшее количество нулей может быть в двоичной записи маски?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'93.138.161.94/{mask}', 0)
    print(net, 32-mask)

    # 93.138.160.0/19 13
    # 93.138.160.0/20 12
    # 93.138.160.0/21 11
    # 93.138.160.0/22 10
    # 93.138.160.0/23 9
'''
# Ответ: 13


# Тип 13 №15949
# Для узла с IP-адресом 98.162.77.94 адрес сети равен 98.162.64.0.
# Для скольких различных значений маски это возможно?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'98.162.77.94/{mask}', 0)
    print(net, net.netmask)

    # 98.162.64.0/18 255.255.192.0
    # 98.162.64.0/19 255.255.224.0
    # 98.162.64.0/20 255.255.240.0
'''
# Ответ: 3


# Тип 13 №16888
# Для узла с IP-адресом 98.162.71.94 адрес сети равен 98.162.71.64.
# Чему равно наименьшее количество возможных адресов в этой сети?
# Примечание. Адрес сети и широковещательный адрес необходимо учитывать при подсчёте.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'98.162.71.94/{mask}', 0)
    print(net, net.num_addresses)  # количество возможных адресов в этой сети

    # 98.162.71.64/26 64
    # 98.162.71.64/27 32
'''
# Ответ: 32


# Для узла с IP-адресом 98.162.71.94 адрес сети равен 98.162.71.64.
# Чему равно наименьшее количество возможных адресов в этой сети?
# Примечание. Адрес сети и широковещательный адрес необходимо не учитывать при подсчёте.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'98.162.71.94/{mask}', 0)
    print(net, net.num_addresses)  # количество возможных адресов в этой сети

    # 98.162.71.64/26 64 - 2 = 62
    # 98.162.71.64/27 32 - 2 = 30
'''
# Ответ: 30


# Тип 13 №2237
# Для некоторой подсети используется маска 255.255.255.192.
# Сколько различных адресов компьютеров теоретически допускает эта маска,
# если два адреса (адрес сети и широковещательный) не используют?
'''
from ipaddress import *
net = ip_network('0.0.0.0/255.255.255.192', 0)
print(net.num_addresses - 2)
'''
# Ответ: 62


# Тип 13 №63062
# Узлы с IP-адресами 120.91.85.213 и 120.91.89.205 находятся в разных сетях.
# Укажите наименьшее возможное значение третьего слева байта маски этой сети.
# Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'120.91.85.213/{mask}', 0)
    net2 = ip_network(f'120.91.89.205/{mask}', 0)
    if net1 != net2:
        print(net1.netmask)

        # 255.255.248.0
        # 255.255.252.0
        # 255.255.254.0
        # 255.255.255.0
'''
# Ответ: 248


# Тип 13 №61393
# Узлы с IP-адресами 120.91.85.213 и 120.91.89.205 находятся в одной сети.
# Укажите наибольшее возможное значение третьего слева байта маски этой сети.
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'120.91.85.213/{mask}', 0)
    net2 = ip_network(f'120.91.89.205/{mask}', 0)
    if net1 == net2:
        print(net1.netmask)

        # 255.255.128.0
        # 255.255.192.0
        # 255.255.224.0
        # 255.255.240.0
'''
# Ответ: 240


# Тип 13 №18588
# Узлы с IP-адресами 98.162.71.151 и 98.162.71.155 находятся в разных сетях.
# Чему равно наименьшее количество возможных единиц в масках этих сетей?
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'98.162.71.151/{mask}', 0)
    net2 = ip_network(f'98.162.71.155/{mask}', 0)
    if net1 != net2:
        print(net1, mask)

        # 98.162.71.144/29 29
        # 98.162.71.148/30 30
        # 98.162.71.150/31 31
        # 98.162.71.151/32 32
'''
# Ответ: 29


# Тип 13 №60255
# Сеть задана IP-адресом 192.168.32.160 и маской сети 255.255.255.240.
# Сколько в этой сети IP-адресов, для которых сумма единиц в двоичной записи IP-адреса чётна?
# В ответе укажите только число.
'''
from ipaddress import *

net = ip_network('192.168.32.160/255.255.255.240', 0)

cnt = 0
for ip in net:
    s = f'{ip:b}'
    if s.count('1') % 2 == 0:
        cnt += 1
print(cnt)
'''
# Ответ: 8

# endregion Урок: ************************************************************


# region Разобрать: *************************************************************

# todo Разобрать Тип 13 №64898
# Узлы с IP-адресами 114.91.57.39 и 114.91.19.61 находятся в одной сети.
# Укажите наименьшее возможное количество принадлежащих этой сети IP-адресов,
# в двоичной записи которых чётное число единиц.
'''
from ipaddress import *
R = []
for mask in range(32+1):
    net1 = ip_network(f'114.91.57.39/{mask}', 0)
    net2 = ip_network(f'114.91.19.61/{mask}', 0)
    if net1 == net2:
        cnt = 0
        for ip in net1:
            s = f'{ip:b}'
            if s.count('1') % 2 == 0:
                cnt += 1
        R.append(cnt)
print(min(R))
'''

# endregion Разобрать: *************************************************************


# Олеся = [1, 2, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19-21 (кодом), 24, 25]
# КЕГЭ = []
# на следующем уроке:
