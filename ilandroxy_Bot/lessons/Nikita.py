# Разбираем ДЗ:

# Тип 24 № 35482
'''
# Текстовый файл содержит строки различной длины. Общий объём файла не превышает 1 Мбайт.
# Строки содержат только заглавные буквы латинского алфавита (ABC…Z).
#
# Необходимо найти строку, содержащую наименьшее количество букв G (если таких строк несколько, надо взять ту, которая находится в файле раньше),
# и определить, какая буква встречается в этой строке чаще всего. Если таких букв несколько, надо взять ту, которая позже стоит в алфавите.
#
# Пример. Исходный файл:
# GIGA
# GABLAB
# AGAAA


f = open('24.txt', 'r')
s = f.readlines()


m = ''
mini = 9999999
for i in range(0, len(s)):
    count = 0
    for j in range(0, len(s[i])):
        if s[i][j] == 'G':
            count += 1
    if mini > count:
        mini = count
        m = s[i]


Alphabet = 'QWERTYUIOPASDFGHJKLZXCVBNM'
res = ''
maxi = 0
for i in Alphabet:
    if m.count(i) > maxi:  # смотрю какое кол-во той или иной буквы (из Alphabet), есть в строке m
        maxi = m.count(i)
        res = i
print(res)
'''
# Ответ: T




# Тип 17 № 45251
'''
# В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно. 
# Определите количество пар последовательности, в которых хотя бы одно число делится на минимальный элемент последовательности, кратный 21. 
# Гарантируется, что такой элемент в последовательности есть. 
# В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

f = open("17.txt", 'r')
M = [int(i) for i in f]

mini = 99999
for i in range(0, len(M)):
    if M[i] % 21 == 0 and M[i] < mini:
        mini = M[i]
print(mini)


count = 0
maxi = -9999
for i in range(0, len(M) - 1):
    if M[i] % mini == 0 or M[i+1] % mini == 0:
        count += 1
        if maxi < M[i] + M[i+1]:
            maxi = M[i] + M[i+1]
print(count, maxi)
'''
# Ответ 126 171120

# Закончили разбирать ДЗ



# Тип 6 № 40981
'''
# Определите, при каком наибольшем введённом значении переменной s данная программа выведет число 121.
# Для Вашего удобства программа представлена на четырёх языках программирования.

for i in range(1, 10000):
    s = i
    s = s // 10
    n = 1
    while s < 221:
        if n % 2 == 0:
            s = s + 13
        n = n + 5
    if n == 121:
        print(i)
'''
# Ответ 779

'''
def Fname(N):
    maxi = -99999
    for i in range(0, len(N)):
        if maxi < N[i]:
            maxi = N[i]
    return maxi


# Немного теории по функциям
M = [1, 6, 87, 43, 4, 5, 6, 7]
print(max(M))
# Написали функцию поиска наибольшего элемента сами.
x = Fname(M)
print(x)
'''




# Тип 16 № 6990
'''
# Алгоритм вычисления значения функции F(n), где n — натуральное число, задан следующими соотношениями:
#
# F(1) = 1;
# F(n) = F(n − 1)+n если n>1

# Чему равно значение функции F(40)? В ответе запишите только натуральное число.

def F(n):
    if n == 1:
        return 1
    if n > 1:
        return F(n - 1) + n

print(F(40))
'''
# Ответ 820



# Тип 16 № 4656
'''
# Алгоритм вычисления значения функции F(n) и G(n), где n – натуральное число, задан следующими соотношениями:
#
# F(1) = 0
# F(n) = F(n–1) + n, при n >1
#
# G(1) = 1
# G(n) = G(n–1) * n, при n >1
#
# Чему равно значение функции F(5) + G(5)?
# В ответе запишите только натуральное число.

def F(n):
    if n == 1:
        return 0
    if n > 1:
        return F(n - 1) + n

def G(n):
    if n == 1:
        return 1
    if n > 1:
        return G(n - 1) * n

x = F(5)
y = G(5)
print(x, y, x + y)
'''
# Ответ 134


# Про типы переменных
M = [1, 2.4, '23', True, [1, 2, 3], (1, 2, 3)]
for i in range(0, len(M)):
    print(type(M[i]))





# Теория математической логики (булевой алгебры) boolean
'''
Python
(not(z))       ¬z      - отрицание (инверсия)
x or y         x ∨ y   - дизъюнкция (логическое сложение)
z and w        z ∧ w   - конъюнкция (логическое умножение)
x <= w         x → w   - импликация
y == z         y ≡ z   - тождество

Приоритет операций: отрицание > конъюнкция > дизъюнкция > импликация

'''

# Тип 2 № 45236
# Миша заполнял таблицу истинности логической функции F
#
# ¬(x → w) ∨ (y ≡ z) ∨ y,
#
# но успел заполнить лишь фрагмент из трёх различных её строк, даже не указав, какому столбцу
# таблицы соответствует каждая из переменных w, x, y, z.

print('\n\nx y z w')
for x in range(2): #[0, 2)
    for y in range(2):
        for z in range(2):
            for w in range(2):
                F = ( (not(x <= w)) or (y == z) or y )
                if F == False:
                    print(z, y, z, w)









