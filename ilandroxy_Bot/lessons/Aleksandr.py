# region Домашка:  ******************************************************************************



# endregion Домашка:  ******************************************************************************



# region Урок:  ******************************************************************************

# № 6885 OpenFIPI (Уровень: Базовый)
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#
# 1. Строится двоичная запись числа N.
#
# 2. К этой записи дописываются справа ещё несколько разрядов по следующему правилу:
#
# а) если N чётное, то к нему справа приписываются два нуля, а слева единица;
#
# б) если N нечётное, то к нему справа приписывается в двоичном виде сумма цифр его двоичной записи;
#
# Полученная таким образом запись (в ней как минимум на один разряд больше, чем в записи исходного числа N)
# является двоичной записью искомого числа R.
#
# Например, исходное число 410 = 1002 преобразуется в число 1100002 = 4810, а исходное число 1310 = 11012
# преобразуется в число 1101112 = 5510.
#
# Укажите такое число N, для которого число R является наименьшим среди чисел, превышающих 190.
# В ответе это число запишите в десятичной системе счисления
'''
R = []
for n in range(1, 1000):
    s = bin(n)[2:]
    if n % 2 == 0:
        s = '1' + s + '00'
    else:
        s = s + bin(s.count('1'))[2:]

    r = int(s, 2)
    if r > 190:
        R.append([r, n])

print(min(R))
'''
# Показать ответ: 16


#
# № 7262 OpenFIPI (Уровень: Базовый)
# Исполнитель Редактор получает на вход строку символов и преобразовывает её.
#
# На вход приведённой ниже программы поступает строка из 180 цифр,
# содержащая по 60 цифр 4, 6 и 8, расположенных в произвольном порядке.
#
# Определите, какие цифры будут находиться на 25-м, 75-м и 150-м местах строки,
# получившейся в результате выполнения программы.
#
# НАЧАЛО
# ПОКА нашлось (46) ИЛИ нашлось (84) ИЛИ нашлось (86)
# ЕСЛИ нашлось (46)
# ТО заменить (46, 64)
# КОНЕЦ ЕСЛИ
# ЕСЛИ нашлось (84)
# ТО заменить (84, 48)
# КОНЕЦ ЕСЛИ
# ЕСЛИ нашлось (86)
# ТО заменить (86, 68)
# КОНЕЦ ЕСЛИ
# КОНЕЦ ПОКА
# КОНЕЦ
'''
s = '6' * 60 + '4' * 60 + '8' * 60
while '46' in s or '84' in s or '86' in s:
    if '46' in s:
        s = s.replace('46', '64', 1)
    if '84' in s:
        s = s.replace('84', '48', 1)
    if '86' in s:
        s = s.replace('86', '68', 1)

print(s[25-1], s[75-1], s[150-1])
'''
# Показать ответ: 648


# № 7265 OpenFIPI (Уровень: Базовый)
# Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на натуральное число m».
# Для какого наименьшего натурального числа А формула
#
# (ДЕЛ(x, 2) → ¬ДЕЛ(x, 3)) \/ (x + A ≥ 100)
#
# тождественно истинна (т.е. принимает значение 1) при любом натуральном значении переменной х?.
'''
def F(x, A):
    return ((x % 2 == 0) <= (x % 3 != 0)) or (x + A >= 100)

for A in range(1, 1000):
    if all(F(x, A) for x in range(1, 1000)):
        print(A)
        break
'''
# Показать ответ: 94


#
# № 7267 OpenFIPI (Уровень: Базовый)
# В файле содержится последовательность натуральных чисел.
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно.
# Определите количество пар последовательности, в которых остаток от деления хотя бы одного из элементов
# на 117 равен минимальному элементу последовательности.
# В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких пар.
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.
'''
M = [int(i) for i in open('17.txt')]
count = 0
maxi = -999999
for i in range(0, len(M)-1):
    if M[i] % 117 == min(M) or M[i+1] % 117 == min(M):
        count += 1
        maxi = max(maxi, M[i] + M[i+1])
print(count, maxi)
'''
# Ответ: 175 173738


#
# № 7272 OpenFIPI (Уровень: Базовый)
# Текстовый файл состоит из символов A, B и C.
#
# Определите максимальное количество идущих подряд пар символов AB или CB в прилагаемом файле.
#
# Искомая подпоследовательность должна состоять только из пар AB, или только из пар CB, или только из пар AB и CB
# в произвольном порядке следования этих пар.
'''
s = open('24.txt').readline()
s = s.replace('AB', '*').replace('CB', '*')
for x in 'ABC':
    s = s.replace(x, ' ')
M = [len(i) for i in s.split()]
print(max(M))
'''
# Ответ: 65


# № 7273 OpenFIPI (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#
# – символ «?» означает ровно одну произвольную цифру;
# – символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
#
# Среди натуральных чисел, не превышающих 10**9, найдите все числа,
# соответствующие маске 12345?7?8, делящиеся на число 23 без остатка.
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# а во втором столбце – соответствующие им результаты деления этих чисел на 23.
'''
for x in '0123456789':
    for y in '0123456789':
        A = int(f'12345{x}7{y}8')
        if A % 23 == 0:
            print(A, A // 23)
'''
# Показать ответ:
# 123450798 5367426
# 123451718 5367466
# 123453788 5367556
# 123454708 5367596
# 123456778 5367686
# 123459768 5367816


# № 7625 Досрочная волна 2023 (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#
# – символ «?» означает ровно одну произвольную цифру;
#
# – символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
#
# Среди натуральных чисел, не превышающих 10**8,
# найдите все числа, соответствующие маске 11??4*56, делящиеся на 211 без остатка.
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# а во втором столбце – соответствующие им результаты деления этих чисел на 211.

# print(10**8)
# print('11??4*56')
'''
import itertools
M = []
for l in range(0, 1+1):
    for s in itertools.product('0123456789', repeat=l):
        s = ''.join(s)
        M.append(s)
print(M)

R = []
for x in '0123456789':
    for y in '0123456789':
        for z in M:
            A = int(f'11{x}{y}4{z}56')
            if A % 211 == 0:
                R.append([A, A // 211])

for x in sorted(R):
    print(*x)
'''
# Показать ответ:
# 1117456 5296
# 11034456 52296
# 11224356 53196
# 11414256 54096
# 11604156 54996
# 11794056 55896


# № 7013 (Уровень: Средний)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#
# - символ «?» означает ровно одну произвольную цифру;
# - символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
#
# Найдите все натуральные числа, не превосходящие 10**9, для которых выполнены все условия:
#
# - соответствуют маске *31*65?;
# - делятся на 31 и 2031 без остатка;
# - количество делителей числа является результатом любой степени двойки
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# справа от каждого числа их частное от деления на 2031.

# print(10**9)
# print('31****65?')
'''
import itertools

def F(x):
    dl = set()
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            dl.add(j)
            dl.add(x // j)
    for i in range(1, 30):
        if len(dl) == 2**i:
            return True
    return False

M = []
for l in range(0, 4+1):
    for s in itertools.product('0123456789', repeat=l):
        s = ''.join(s)
        M.append(s)

R = []
for x in '0123456789':
    for y in M:
        for z in M:
            A = int(f'{y}31{z}65{x}')
            if A <= 10**9:
                if A % 31 == 0 and A % 2031 == 0:
                    if F(A) == True:
                        R.append([A, A // 2031])
                        print(A, A // 2031)

for x in sorted(R):
    print(*x)
'''
# Показать ответ:
# 53831655 26505
# 333126651 164021
# 512313657 252247
# 647931651 319021
# 831966654 409634

# endregion Урок:  ******************************************************************************


# todo: Александр = [2, 3, 5, 6, 8, 9, 12, 14+, 15, 16, 17, 18, 19-21, 22, 23, 24+, 25]
# на прошлом уроке: Прорешивали первый вариант нового Фипи, рассмотрели до 15 задачи.
# на следующем уроке: