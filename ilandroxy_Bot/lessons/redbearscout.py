# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************


# region Урок: ******************************************************************

# КЕГЭ № 6903 (Уровень: Базовый) (Д. Статный)
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
# 1. Строится двоичная запись числа N.
# 2. Далее эта запись обрабатывается по следующему правилу:
#     а) если сумма цифр в двоичной записи числа чётная,
#     то к этой записи справа дописывается 00, а затем два левых разряда заменяются на 11;
#     б) если сумма цифр в двоичной записи числа нечётная,
#     то к этой записи справа дописывается 11, а затем два левых разряда заменяются на 10.
# 3. Пункт 2 повторяется ещё раз к записи, полученной после второго пункта.

# Найдите максимальное число R, которое получается при обработке N, меньших 100. В ответе укажите R.
'''
R = []
for n in range(1, 100):
    s = bin(n)[2:]  # 1. Строится двоичная запись числа N.
    for i in range(2):  # 3. Пункт 2 повторяется ещё раз к записи, полученной после второго пункта.
        if s.count('1') % 2 == 0:   # если сумма цифр в двоичной записи числа чётная
            s = '11' + s[2:] + '00'  # к этой записи справа дописывается 00, а затем два левых разряда заменяются на 11
        else:  # если сумма цифр в двоичной записи числа нечётная
            s = '10' + s[2:] + '11'  # к этой записи справа дописывается 11, а затем два левых разряда заменяются на 10
    r = int(s, 2)  # переводим строчку s из 2-ой в 10-ную систему счисления
    R.append(r)
print(max(R))
'''
# Ответ: 1584


# КЕГЭ № 6884 OpenFIPI (Уровень: Базовый)
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#
# 1. Строится двоичная запись числа N.
# 2. К этой записи дописываются справа и слева ещё по одному или два разряда по следующему правилу:
#     а) если N чётное, то в конец числа (справа) дописывается нуль, а в начало числа (слева) дописывается единица;
#     б) если N нечётное, то в конец числа (справа) и в начало числа (слева) дописываются по две единицы.

# Укажите наименьшее число R, превышающее 225, которое может являться результатом работы данного алгоритма.
# В ответе это число запишите в десятичной системе счисления.
'''
R = []
for n in range(1, 1000):
    s = bin(n)[2:]  # берем все символы начиная со 2 индекса
    if n % 2 == 0:  # если N чётное
        s = '1' + s + '0'
    else:
        s = '11' + s + '11'
    r = int(s, 2)  # функция int переводит строчку s из 2-ой в 10-ую систему счисления
    if r > 225:
        R.append(r)

print(min(R))
'''
# Ответ: 228


# Теория списков list
# - В списке может храниться неограниченное кол-во элементов разных типов данных
# - Каждый элемент списка имеет порядковый номер - индекс
# - Индексы считаются слева-направо начиная с 0 и справа-налево начиная с -1
# - Элементы списков можно изменять через индексы
'''
# i   0    1    2    3    4
M = ['a', 'b', 'c', 'd', 'e']
# -i -5   -4   -3   -2   -1

print(f'Первый элемент списка M: {M[0]} \n'
      f'Последний элемент списка M: {M[-1]}')

# Первый элемент списка M: a
# Последний элемент списка M: e

M[-1] = 'КОНЕЦ'
print(M)  # ['a', 'b', 'c', 'd', 'КОНЕЦ']
'''


# i   0    1    2    3    4
M = ['a', 'b', 'c', 'd', 'e']
# -i -5   -4   -3   -2   -1

'''
# Пробегать списки по индексам через for
print(len(M))  # 5 - функция len() возвращает длину списка (кол-во элементов в нем)

for i in range(0, len(M)):
    # print(i, end=' ')  # 0 1 2 3 4
    print(M[i], end=' ')  # a b c d e
print()

# Пробегаем элементы списка по индексам и изменяем их:
for i in range(0, len(M)):
    M[i] = M[i] * i
print(M)  # ['', 'b', 'cc', 'ddd', 'eeee']


M = ['a', 'b', 'c', 'd', 'e']

# Просто пробегаем все элементы списка
for x in M:
    print(x, end=' ')  # a b c d e
print()

# Таким образом мы можем отсеивать ненужные элементы
for x in M:
    if x in 'bcd':
        print(x, end=' ')  # b c d 
print()
'''


# i   0    1    2    3    4
M = ['a', 'b', 'c', 'd', 'e']
# -i -5   -4   -3   -2   -1

# Срезы списков
'''
print(M[0])  # a - первый элемент списка
print(M[0:3])  # ['a', 'b', 'c'] - 3 индекс не входит
print(M[:3])  # ['a', 'b', 'c'] - все, что слева от 3 (не включая 3 индекса)
print(M[2:])  # ['c', 'd', 'e'] - все, что начиная со 2 индекса
print(M[:])  # ['a', 'b', 'c', 'd', 'e']
print(M[::])  # ['a', 'b', 'c', 'd', 'e']
print(M[::2])  # ['a', 'c', 'e'] - взяли все элементы на четных индексах 
print(M[1::2])  # ['b', 'd'] - взяли все элементы на нечетных индексах
print(M[::-1])  # ['e', 'd', 'c', 'b', 'a'] - в обратном порядке 
'''

M = [3, 7, 4, 7, 5, 6, 7]

# Функции и методы списков:
'''
print(sum(M))  # 39 - сумма чисел списка
print(len(M))  # 7 - длина списка (кол-во элементов в нем)
print(max(M))
print(min(M))

print(set(M))  # {3, 4, 5, 6, 7} - переконвертировали в set (множество) - убрали копии элементов
print(len(set(M)))  # 5 - кол-во элементов без повторений (без копий)

print(sorted(M))  # [3, 4, 5, 6, 7, 7, 7] - сортировка в порядке возростания
print(sorted(M, reverse=True))  # [7, 7, 7, 6, 5, 4, 3] - сортировка в порядке убывания


print(M.count(7))  # 3 - кол-во вхождений элемента в список
print(M.index(7))  # 1 - возвращает индекс первого найденного элемента

M.append(10)  # - добавляет новые элементы в конец списка
print(M)  # [3, 7, 4, 7, 5, 6, 7, 10]

M.reverse()  # разворачивает список в обратно порядке
print(M)  # [10, 7, 6, 5, 7, 4, 7, 3]
'''
# endregion Урок: ******************************************************************


# region Разобрать: *************************************************************

# endregion Разобрать: *************************************************************


# Тимур = [2.1, 5.1, 6.1, 14.1]
# КЕГЭ  = []
# на следующем уроке:
