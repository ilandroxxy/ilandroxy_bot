# region Домашка: ******************************************************************************

# № 4739 (Уровень: Средний)
# (А. Куканова) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
#
# F(n) = n − 10000 при n > 10000;
# F(n) = F(n + 1) + F(n + 2), если 1 ≤ n ≤ 10000.
# Чему равно значение выражения F(12345) × (F(10) − F(12)) / F(11) + F(10101)?
'''
def F(n):
    if n > 10000:
        return n - 10000
    if 1 <= n <= 10000:
        return F(n + 1) + F(n + 2)

print(F(12345))
print(F(10101))
'''
# F(12345) * (F(10) − F(12)) / F(11) + F(10101)
# 2345 * (F(10) − F(12)) / F(11) + 101
# F(10) = F(11) + F(12)
# 2345 * (F(11) + F(12) − F(12)) / F(11) + 101
# 2345 * (F(11) + 0) / F(11) + 101
# 2345 * 1 + 101
# Ответ: 2446
# endregion Домашка: ******************************************************************************


# region Урок: ******************************************************************************

# № 5126 /dev/inf 11.22 (Уровень: Средний)
# (А. Рогов) Откройте файл электронной таблицы, содержащей в каждой строке шесть натуральных чисел.
# Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
#
# – в строке только одно число повторяется ровно три раза, остальные числа различны;
# – среднее арифметическое неповторяющихся чисел строки не больше суммы повторяющихся чисел.
'''
count = 0
for s in open('9.txt'):
    M = [int(i) for i in s.split()]
    if len(set(M)) == 4 and any(M.count(i) == 3 for i in M):
        copied = (sum(M) - sum(set(M))) / 2
        if (sum(M) - copied * 3) / 3 <= copied * 3:
            count += 1
print(count)
'''
# Показать ответ: 125


#
# № 6897 OpenFIPI (Уровень: Средний)
# Откройте файл электронной таблицы, содержащей в каждой строке четыре натуральных числа.
# Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
#
# – наибольшее из четырёх чисел меньше суммы трёх других;
# – четыре числа нельзя разбить на две пары чисел с равными суммами.
'''
import itertools
count = 0
for s in open('9.txt'):
    M = [int(i) for i in s.split()]
    if max(M) < sum(M) - max(M):
        # if all(A[0] + A[1] != A[2] + A[3] for A in itertools.permutations(M, 4)):
        if all(sum(A[:2]) != sum(A[2:]) for A in itertools.permutations(M, 4)):
            count += 1
print(count)
'''
# Показать ответ: 2396


# Если нужно все строки считать в один большой список:
# M = [int(i) for i in open('9.txt').read().split()]
# print(M)


# № 5140 /dev/inf 11.22 (Уровень: Базовый)
# (А. Рогов) Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#
# – символ «?» означает ровно одну произвольную цифру;
#
# – символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
#
# Среди натуральных чисел, не превышающих 10**10, найдите все числа, соответствующие маске
#
# 32?056*6, делящиеся на 2023 без остатка.
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# а во втором столбце – соответствующие им результаты деления этих чисел на 2023.

# print(10**10)
# print('32?056***6')
'''
import itertools
M = []
for l in range(0, 3+1):
    for s in itertools.product('0123456789', repeat=l):
        s = ''.join(s)
        M.append(s)

R = []
for x in M:
    for y in '0123456789':
        A = int(f'32{y}056{x}6')
        if A % 2023 == 0:
            R.append([A, A//2023])

for x in sorted(R):
    print(*x)
'''
# Показать ответ:
# 323056916 159692
# 3210565736 1587032
# 3240566826 1601862
# 3250560446 1606802
# 3270567916 1616692
# 3280561536 1621632



# № 5139 /dev/inf 11.22 (Уровень: Средний)
# (А. Рогов) Текстовый файл состоит из символов A, B, C, D, E, F и U.
# Определите максимальное количество идущих подряд троек символов вида
#
# согласная + гласная + согласная
'''
import itertools
M = []
for s in itertools.permutations('ABCDEFU', 3):
    s = ''.join(s)
    if s[1] in 'AEU' and s[0] in 'BCDF' and s[2] in 'BCDF':
        M.append(s)
print(M)

s = open('24.txt').readline()
for x in M:
    s = s.replace(x, '*')
for a in 'ABCDEFU':
    s = s.replace(a, ' ')
A = [len(i) for i in s.split()]
print(max(A))
'''
# Показать ответ: 6


# endregion Урок: ******************************************************************************


# todo: Степан = [1, 2, 3, 4, 5, 7, 8, 9, 13, 14+, 15+, 16, 17, 18, 19-21, 22, 23, 24, 25.2]
# на прошлом уроке: Разбирали задачи с варианта /dev/inf #1 , номера: 9, 25
# на следующем уроке:
