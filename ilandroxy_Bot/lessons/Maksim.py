# region Домашка: ************************************************************

# endregion Домашка: *********************************************************


# region Урок: ************************************************************

# Тип 24 №48472
# Текстовый файл содержит только буквы A, C, D, F, O.
# Определите максимальное количество идущих подряд групп символов вида
# гласная + гласная + согласная.
'''
s = open('24.txt').readline()
s = s.replace('C', 'D').replace('F', 'D').replace('O', 'A')
s = s.replace('AAD', '*')
s = s.replace('A', ' ').replace('D', ' ')
print(max([len(x) for x in s.split()]))
'''
import ctypes

# Ответ: 4


# Тип 24 №27699
# Текстовый файл состоит не более чем из 106 символов L, D и R.
# Определите максимальную длину цепочки вида LDRLDRLDR...
# (составленной из фрагментов LDR, последний фрагмент может быть неполным).
'''
print(open('24.txt').readline())
print(len('LDRLDRLDRLDRLDR'))
'''
# Ответ: 15


# Тип 24 №38958
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите максимальное количество идущих подряд символов, среди которых не более одной буквы A.
'''
s = open('24.txt').readline().split('A')
maxi = 0
for i in range(len(s)-1):
    r = s[i] + 'A' + s[i+1]
    maxi = max(maxi, len(r))
print(maxi)
'''
# Ответ: 337


# Тип 24 №63073
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите максимальное количество идущих подряд символов, среди которых
# каждая из букв C и D встречается не более двух раз.
'''
s = open('24.txt').readline()
s = s.replace('C', 'C ').replace('D', 'D ').split()
maxi = 0
for i in range(len(s)-4):
    r = s[i] + s[i+1] + s[i+2] + s[i+3] + s[i+4][:-1]
    if r.count('C') == 2 and r.count('D') == 2:
        maxi = max(maxi, len(r))
print(maxi)
'''
# Ответ: 253


# КЕГЭ № 5223 (Уровень: Базовый)
'''
s = open('24.txt').readline().replace('DD', 'D D')
print(max([len(x) for x in s.split() if 'FE' in x]))
'''

# КЕГЭ № 2499 (Уровень: Базовый)
'''
cnt = 0
s = open('24.txt').readline()
for i in range(len(s) - 3):
    # if s[i] + s[i + 1] + s[i+2] + s[i + 3] == 'XXXX':
    if s[i:i + 4] == 'XXXX':
        cnt += 1
print(cnt)
'''


# КЕГЭ № 2509 (Уровень: Средний)
# Текстовый файл состоит не более чем из 10**6 символов
# и содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите количество самого частого и самого редкого символа в файле (без учёта символа окончания строки).
# В качестве ответа запишите разницу между ними.
'''
R = []
s = open('24.txt').readline()
alph = sorted('QWERTYUIOPASDFGHJKLZXCVBNM')
for a in alph:
    R.append(s.count(a))
print(max(R) - min(R))
'''


# Тип 24 №29672
# Текстовый файл содержит строки различной длины.
# Строки содержат только заглавные буквы латинского алфавита (ABC…Z).
# Определите количество строк, в которых буква E встречается чаще, чем буква A.
'''
s = open('24.txt').readlines()
cnt = 0
for x in s:
    if x.count('E') > x.count('A'):
        cnt += 1
print(cnt)
'''
# Ответ: 467


# Тип 24 №33494
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите символ, который чаще всего встречается в файле сразу после буквы E.
'''
s = open('24.txt').readline()
M = []
for i in range(len(s)-1):
    if s[i] == 'E':
        M.append(s[i+1])

R = []
for a in sorted('QWERTYUIOPASDFGHJKLZXCVBNM'):
    R.append([M.count(a), a])
print(max(R))
'''
# Ответ: Y


# Тип 24 №33526
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите символ, который чаще всего встречается в файле между двумя одинаковыми символами.
'''
s = open('24.txt').readline()
M = []
for i in range(len(s)-2):
    if s[i] == s[i+2]:
        M.append(s[i+1])

R = []
for a in sorted('QWERTYUIOPASDFGHJKLZXCVBNM'):
    R.append([M.count(a), a])
print(max(R))
'''
# Ответ: D


# Тип 24 №35913
# Текстовый файл содержит строки различной длины.
# Строки содержат только заглавные буквы латинского алфавита (ABC…Z).
#
# Необходимо найти строку, содержащую наименьшее количество букв N
# (если таких строк несколько, надо взять ту, которая находится в файле раньше),
# и определить, какая буква встречается в этой строке чаще всего.
# Если таких букв несколько, надо взять ту, которая позже стоит в алфавите.
'''
s = open('24.txt').readlines()
mini = 99999
r = ''
for x in s:
    if mini > x.count('N'):  # > которая находится в файле раньше
        mini = x.count('N')
        r = x  
 
maxi = 0
for a in sorted('QWERTYUIOPASDFGHJKLZXCVBNM'):
    if maxi <= r.count(a):  # <= которая позже стоит в алфавите
        maxi = r.count(a)
        print(maxi, a)
'''
# Ответ: Y


# Теория:

# Адрес сети = IP-адресу узла & Маска

# 1 and 1 = 1
# 1 and 0 = 0
# 0 and 1 = 0
# 0 and 0 = 0

# IP адрес имеет вид: 4 числа разделенные точкой, на каждое число выделяется по 1 байту, то есть по 8 бит
# Таким образом диапазон допустимых значений для этих чисел от 0 (00000000) до 255 (11111111)

# Маска сети имеет длину 32 бита и принимает вид: 111111..000, например: 11111111.11111111.11100000.00000000

# Тип 13 №3850
# По заданным IP-адресу узла и маске определите адрес сети.
# IP –адрес узла: 217.8.162.162
# Маска: 255.255.224.0

# Вариант 1
'''
knot = '.'.join([bin(int(x))[2:].zfill(8) for x in '217.8.162.162'.split('.')])
mask = '.'.join([bin(int(x))[2:].zfill(8) for x in '255.255.224.0'.split('.')])

address = ''
for i in range(len(knot)):
    if knot[i] == '1' and mask[i] == '1':
        address += '1'
    elif knot[i] == '.' and mask[i] == '.':
        address += '.'
    else:
        address += '0'

print(knot, mask, address, sep='\n')
# 11011001.00001000.10100010.10100010
# 11111111.11111111.11100000.00000000
# 11011001.00001000.10100000.00000000

print([int(x, 2) for x in address.split('.')])
# [217, 8, 160, 0]
'''
# Ответ: HBFA


# # Вариант 2
'''
# IP –адрес узла: 217.8.162.162
# Маска: 255.255.224.0
knot = [int(x) for x in '217.8.162.162'.split('.')]
mask = [int(x) for x in '255.255.224.0'.split('.')]
print([knot[i] & mask[i] for i in range(4)])

# [217, 8, 160, 0]
'''
# Ответ: HBFA


# Тип 13 №3850
# По заданным IP-адресу узла и маске определите адрес сети.
# IP –адрес узла: 217.8.162.162
# Маска: 255.255.224.0

# Вариант 3
'''
from ipaddress import *
net = ip_network('217.8.162.162/255.255.224.0', 0)
print(net)  # 217.8.160.0/19, где 19 - это кол-во единиц в маске
print(f'{net.netmask:b}')  # 11111111111111111110000000000000
'''
# Ответ: HBFA


# Тип 13 №18714
# Для узла с IP-адресом 113.191.37.168 адрес сети равен 113.191.37.160.
# Чему равно наибольшее возможное количество единиц в последнем байте этой маске сети?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'113.191.37.168/{mask}', 0)
    print(net, net.netmask, mask-24)
    # 113.191.37.160/27 255.255.255.224 3
    # 113.191.37.160/28 255.255.255.240 4
'''

'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'113.191.37.168/{mask}', 0)
    if str(net) == f'113.191.37.160/{mask}':
        print(net, net.netmask, mask-24)


from ipaddress import *
maxi = 0
for mask in range(32+1):
    net = ip_network(f'113.191.37.168/{mask}', 0)
    if str(net) == f'113.191.37.160/{mask}':
        maxi = max(maxi, mask-24)
print(maxi)
'''
# Ответ: 4


# Тип 13 №2237
# Для некоторой подсети используется маска 255.255.255.192.
# Сколько различных адресов компьютеров теоретически допускает эта маска,
# если два адреса (адрес сети и широковещательный) не используют?
'''
from ipaddress import *
net = ip_network('0.0.0.0/255.255.255.192', 0)
print(net.num_addresses - 2)  # (адрес сети и широковещательный) не используют
'''
# Ответ: 62


# Тип 13 №7696
# Для узла с IP-адресом 224.128.112.142 адрес сети равен 224.128.96.0.
# Чему равен третий слева байт маски? Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'224.128.112.142/{mask}', 0)
    print(net, net.netmask)
    # 224.128.96.0/19 255.255.224.0
'''
# Ответ: 224


# Тип 13 №10386
# Для узла с IP-адресом 111.81.208.27 адрес сети равен 111.81.192.0.
# Чему равно наименьшее возможное значение третьего слева байта маски?
# Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'111.81.208.27/{mask}', 0)
    print(net, net.netmask)
    # 111.81.192.0/18 255.255.192.0
    # 111.81.192.0/19 255.255.224.0
'''
# Ответ: 192


# Тип 13 №15797
# Для узла с IP-адресом 98.162.201.94 адрес сети равен 98.162.192.0.
# Для скольких различных значений маски это возможно?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'98.162.201.94/{mask}', 0)
    print(net, net.netmask)
    # 98.162.192.0/18 255.255.192.0
    # 98.162.192.0/19 255.255.224.0
    # 98.162.192.0/20 255.255.240.0
'''

'''
from ipaddress import *
cnt = 0
for mask in range(32+1):
    net = ip_network(f'98.162.201.94/{mask}', 0)
    if str(net) == f'98.162.192.0/{mask}':
        cnt += 1
print(cnt)
'''
# Ответ: 3


# Тип 13 №27270
# Для узла с IP-адресом 84.77.95.123 третий слева байт маски равен 224.
# Чему равен третий байт адреса сети для этого узла?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'84.77.95.123/{mask}', 0)
    print(net, net.netmask)
    # 84.77.64.0/19 255.255.224.0
'''
# Ответ: 64


# Тип 13 №16815
# Для узла с IP-адресом 98.162.71.94 адрес сети равен 98.162.71.64.
# Чему равно наибольшее количество возможных адресов в этой сети?
#
# Примечание. Адрес сети и широковещательный адрес необходимо учитывать при подсчёте.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'98.162.71.94/{mask}', 0)
    print(net, net.num_addresses)
    # 98.162.71.64/26 64
    # 98.162.71.64/27 32
'''
# Ответ: 64


# Тип 13 63029
# Узлы с IP- адресами 120.91.176.213 и 120.91.174.205 находятся в разных сетях.
# Укажите наименьшее возможное значение третьего слева байта маски этой сети.
# Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'120.91.176.213/{mask}', 0)
    net2 = ip_network(f'120.91.174.205/{mask}', 0)
    if net1 != net2:
        print(net1.netmask)
        # 255.255.240.0
        # 255.255.248.0
        # 255.255.252.0
'''
# Ответ: 240


# Тип 13 №18588
# Узлы с IP-адресами 98.162.71.151 и 98.162.71.155 находятся в разных сетях.
# Чему равно наименьшее количество возможных единиц в масках этих сетей?
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'98.162.71.151/{mask}', 0)
    net2 = ip_network(f'98.162.71.155/{mask}', 0)
    if net1 != net2:
        print(net1, net1.netmask, mask)
        # 98.162.71.144/29 255.255.255.248 29
        break
'''
# Ответ: 29


# Тип 13 №60255
# Сеть задана IP-адресом 192.168.32.160 и маской сети 255.255.255.240.
# Сколько в этой сети IP-адресов, для которых сумма единиц в двоичной записи IP-адреса чётна?
# В ответе укажите только число.
'''
from ipaddress import *
net = ip_network('192.168.32.160/255.255.255.240', 0)
cnt = 0
for ip in net:
    s = f'{ip:b}'
    if s.count('1') % 2 == 0:
        cnt += 1
print(cnt)
'''
# Ответ: 8





# endregion Урок: ************************************************************


# region Разобрать: *************************************************************

# endregion Разобрать: *************************************************************


# Максим = [2, 6, 5, 8, 9, 12, 13, 14, 15, 16, 17, 23, 24, 25]
# КЕГЭ = []
# на следующем уроке:
