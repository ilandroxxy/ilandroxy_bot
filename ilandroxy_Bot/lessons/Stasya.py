
# region Домашка: **********************************************************


# endregion Домашка: **********************************************************


# region Урок: **********************************************************

# № 6740 Апробация 10.03.23 (Уровень: Базовый)
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#
# 1. Строится двоичная запись числа N.
# 2. Далее эта запись обрабатывается по следующему правилу:
# а) если число чётное, то к двоичной записи числа слева дописывается 10;
# 6) если число нечётное, то к двоичной записи числа слева дописывается 1 и справа дописывается 01.
#
# Полученная таким образом запись является двоичной записью искомого числа R.
#
# Например, для исходного числа 4_10 = 100_2, результатом является число 20_10 = 10100_2,
# а для исходного числа 5_10 = 101_2 результатом является число 53_10 = 110101_2

# Укажите максимальное число R, которое может быть результатом работы данного алгоритма,
# при условии, что N не больше 8. В ответе запишите это число в десятичной системе счисления.
'''
for n in range(1, 8+1):
    s = bin(n)[2:]   # 1. Строится двоичная запись числа N.

    if n % 2 == 0:
        s = '10' + s  # а) если число чётное, то к двоичной записи числа слева дописывается 10;
    else:
        s = '1' + s + "01"  # 6) если число нечётное, то к двоичной записи числа слева дописывается 1 и справа дописывается 01.

    r = int(s, 2)
    print(n, r)
'''
# Показать ответ: 61


# № 6750 Апробация 10.03.23 (Уровень: Базовый)
# Для какого наибольшего целого неотрицательного числа А выражение

# (x + y ≤ 32) ∨ (y ≤ x + 4) ∨ (y ≥ A)

# тождественно истинно (т.е. принимает значение 1) при любых целых положительных х и y?
'''
def F(x, y, A):
    return (x + y <= 32) or (y <= x + 4) or (y >= A)

for A in range(0, 1000):
    if all(F(x, y, A) for x in range(0, 100) for y in range(0, 100)):
        print(A)
'''
'''
# Вариант 2
for A in range(0, 1000):
    if all(((x + y <= 32) or (y <= x + 4) or (y >= A)) for x in range(0, 100) for y in range(0, 100)):
        print(A)
'''
'''
# Вариант 3
print(max([A for A in range(0, 1000) if all(((x + y <= 32) or (y <= x + 4) or (y >= A)) for x in range(0, 100) for y in range(0, 100))]))
'''
# Показать ответ: 19


# № 6741 Апробация 10.03.23 (Уровень: Базовый)
# В начальный момент Черепаха находится в начале координат и направлена вверх
# (вдоль положительного направления оси ординат).
#
# Черепахе был дан для исполнения следующий алгоритм:
# Повтори 4 [Вперёд 10 Направо 270]
# Поднять хвост
# Вперёд 3 Направо 270 Вперёд 5 Направо 90
# Опустить хвост
# Повтори 2 [Вперёд 10 Направо 270 Вперёд 12 Направо 270]
#
# Определите, сколько точек с целочисленными координатами будут находиться внутри объединения фигур,
# ограниченных заданными алгоритмом линиями, включая точки на линиях.
'''
import turtle as t
t.left(90)
t.speed(10)
l = 30

for i in range(4):
    t.forward(10 * l)  # Повтори 4 [Вперёд 10 Направо 270]
    t.right(270)
t.up()  # Поднять хвост  - прочитать документацию # print(t.up.__doc__)
t.forward(3 * l)
t.right(270)
t.forward(5 * l)  # Вперёд 3 Направо 270 Вперёд 5 Направо 90
t.right(90)
t.down()  # Опустить хвост
t.color('blue')    # поменяем цвет пера
for i in range(2):
    t.forward(10 * l)
    t.right(270)  # Повтори 2 [Вперёд 10 Направо 270 Вперёд 12 Направо 270]
    t.forward(12 * l)
    t.right(270)

t.up()
for x in range(0, -20, -1):
    for y in range(0, 15):
        t.goto(x * l, y * l)
        t.dot(3, 'red')

t.done()
'''
# Показать ответ: 216


# № 6752 Апробация 10.03.23 (Уровень: Базовый)
# В файле содержится последовательность целых чисел.
# Элементы последовательности могут принимать целые значения от —100 000 до 100 000 включительно.
# Определите количество пар последовательности, в которых хотя бы одно число отрицательно,
# а сумма чисел пары меньше количества чисел в последовательности, делящихся на 3.
# В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких пар.
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.
'''
# Вариант 1: количества чисел в последовательности, делящихся на 3
lenght1 = len([int(i) for i in open('17.txt') if int(i) % 3 == 0])

M = [int(i) for i in open('17.txt')]

lenght2 = 0
for x in M:  # Вариант 2: количества чисел в последовательности, делящихся на 3
    if x % 3 == 0:
        lenght2 += 1

count = 0
maxi = 0
for i in range(0, len(M)-1):
    if M[i] < 0 or M[i+1] < 0:
        if (M[i] + M[i+1]) < lenght1:
            count += 1
            maxi = max(maxi, M[i] + M[i+1])  # затем максимальную из сумм элементов таких пар
print(count, maxi)
'''
# Показать ответ: 5128 3322


# № 6756 Апробация 10.03.23 (Уровень: Базовый)
# У исполнителя есть две команды, которые обозначены латинскими буквами:
#
# А. Вычти 2
# В. Найди целую часть от деления на 2

# Сколько существует программ, для которых при исходном числе 40 результатом является число 2,
# и при этом траектория вычислений содержит число 10?
'''
print(int(True))
print(True + True + True + False + True)

# Вариант 1
def F(a, b):
    if a < b:
        return 0
    elif a == b:
        return 1
    else:
        return F(a-2, b) + F(a//2, b)

print(F(40, 10) * F(10, 2))

# Вариант 2
def F(a, b):
    if a <= b:
        return a == b
    else:
        return F(a-2, b) + F(a//2, b)

print(F(40, 10) * F(10, 2))
'''
# Показать ответ: 40


# № 6757 Апробация 10.03.23 (Уровень: Базовый)
# Текстовый файл состоит из символов С, D, Е и F.
# Определите максимальное количество идущих подряд последовательностей символов CFE или FCE в прилагаемом файле.
# Искомая подпоследовательность должна состоять только из троек CFE, или только из троек FCE,
# или только из троек CFE или FCE в произвольном порядке их следования.
#
# Для выполнения этого задания следует написать программу.
'''
s = open('24.txt').readline()
s = s.replace('CFE', '*').replace('FCE', '*')
s = s.replace('C', ' ').replace('D', ' ').replace('E', ' ').replace('F', ' ')
M = [len(i) for i in s.split()]
print(max(M))
'''
# Показать ответ: 103


# № 6758 Апробация 10.03.23 (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#
# — символ «?» означает ровно одну произвольную цифру;
# — символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
#
# Среди натуральных чисел, не превышающих 10**8, найдите все числа,
# соответствующие маске 2*5443?1, делящиеся на 23 без остатка.
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# а во втором столбце — соответствующие им результаты деления этих чисел на 23.
#
# Количество строк в таблице для ответа избыточно.

# print(10**8)
# print('2*5443?1')

# Решение правильное, но не соответствует условию
'''
for x in range(0, 9+1):
    for y in range(0, 9+1):
        A = int(f'2{x}5443{y}1')
        if A % 23 == 0:
            print(A, A//23)
'''
'''
import itertools  # # Например, маске 123*4?5 соответствуют числа 123405 и 12300405. - могут быть 00
M = ['']  # # в том числе «*» может задавать и пустую последовательность.
for l in range(1, 1+1):
    for s in itertools.product('0123456789', repeat=l):
        M.append(''.join(s))
print(M)

R = []
for x in M:
    for y in range(0, 9+1):
        A = int(f'2{x}5443{y}1')
        if A % 23 == 0:
            R.append([A, A // 23])

for x in sorted(R):  # все найденные числа в порядке возрастания
    print(*x)
'''
# Показать ответ:
# 22544301 980187
# 23544341 1023667
# 24544381 1067147
# 28544311 1241057
# 29544351 1284537



# endregion Урок: **********************************************************


# todo: Стася = [1, 2, 3, 4, 5, 6, 8, 9.2, 12, 14+, 15, 16, 17, 18, 19-21, 22, 23, 24, 25.2]
# на прошлом уроке: Разбирали задачи 1, 7, 5, 6, 15,17,23-25 с апробации.
# на следующем уроке:

