
# region Домашка: **********************************************************

# Тип 25 № 27850
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [245_690;245_756] простые числа.
# Выведите на экран все найденные простые числа в порядке возрастания, слева от каждого числа выведите его порядковый номер в последовательности.
# Каждая пара чисел должна быть выведена в отдельной строке.
'''
def D(x):
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            return False
    return True

k = 1
for x in range(245_690, 245_756+1):
    if D(x) == True:
        print(k, x)
    k += 1
'''
# Ответ:
# 22 245711
# 30 245719
# 34 245723
# 52 245741
# 58 245747
# 64 245753



#Тип 25 № 27422
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [174_457;174_505], числа, имеющие ровно два различных натуральных делителя, не считая единицы и самого числа.
# Для каждого найденного числа запишите эти два делителя в два соседних столбца на экране с новой строки в порядке возрастания произведения этих двух делителей.
# Делители в строке также должны следовать в порядке возрастания.
'''
def D(x):
    d1 = set()
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d1.add(j)
            d1.add(x // j)
            if len(d1) > 2:
                return d1
    return sorted(d1)


for j in range(174_457, 174_505+1):
    if len(D(j)) == 2:
        print(*D(j))
'''

'''
def D(x):
    k = 2
    d1 = set()
    while k * k <= x:
        if x % k == 0:
            d1.add(k)
            if x // j < x:
                d1.add(x // k)
        k = k + 1
    return sorted(d1)

for j in range(174_457, 174_505+1):
    if len(D(j)) == 2:
        print(*D(j))
'''
# Ответ:
# 3 58153
# 7 24923
# 59 2957
# 13 13421
# 149 1171
# 5 34897
# 211 827
# 2 87251


# Тип 25 № 28123
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [125_256;125_330], числа, имеющие ровно шесть различных чётных натуральных делителей.
# Для каждого найденного числа запишите эти шесть делителей в шесть соседних столбцов на экране с новой строки.
# Делители в строке должны следовать в порядке возрастания.
'''
def D(x):
    d1 = set()
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            if j % 2 == 0:
                d1.add(j)
            if (x // j) % 2 == 0:
                d1.add(x // j)
            if len(d1) > 6:
                return d1
    return sorted(d1)

for x in range(125_256, 125_330+1):
    d1 = D(x)
    if len(d1) == 6:
        print(*d1)
'''
# Ответ:
# 2 6 18 13918 41754 125262
# 2 4 8 31322 62644 125288
# 2 6 18 13922 41766 125298


# Тип 25 № 27856
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [95_632;95_650], числа, имеющие ровно шесть различных нечётных натуральных делителей (при этом количество четных делителей может быть любым).
# Для каждого найденного числа запишите эти шесть делителей в шесть соседних столбцов на экране с новой строки.
# Делители в строке должны следовать в порядке возрастания.
'''
def D(x):
    d1 = set()
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            if j % 2 != 0:
                d1.add(j)
            if (x // j) % 2 != 0:
                d1.add(x // j)
            if len(d1) > 6:
                return d1
    return sorted(d1)

for x in range(95_632, 95_650+1):
    d1 = D(x)
    if len(d1) == 6:
        print(*d1)
'''
# Ответ:
# 1 3 9 10627 31881 95643
# 1 7 49 61 427 2989
# 1 5 25 1913 9565 47825


# Тип 25 № 47022
# Пусть M(N) — пятый по величине делитель натурального числа N без учёта самого числа и единицы.
#
# Если у числа N меньше 5 различных делителей, не считая единицы и самого числа, считаем, что M(N)=0.
#
# Найдите 5 наименьших натуральных чисел, превышающих 300_000_000, для которых M(N)>0.
# В ответе запишите найденные значения M(N) в порядке возрастания соответствующих им чисел N.
'''
def D(x):
    dl = set()
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            dl.add(j)
            dl.add(x // j)
            if len(dl) > 10:
                return sorted(dl)
    return sorted(dl)

k = 0
for x in range(300_000_000+1, 300_000_000_000+1):
    dl = D(x)
    if len(dl) >= 5:
        M = dl[-5]
        if M > 0:
            print(M)
            k += 1
            if k == 5:
                break
'''
# Ответ:
# 17
# 1119403
# 151
# 16666667
# 27272728

# endregion Домашка: **********************************************************


# region Урок: **********************************************************

# Тип 24 № 27687
# Текстовый файл состоит не более чем из 10**6 символов X, Y и Z.
# Определите длину самой длинной последовательности, состоящей из символов Y.
# Хотя бы один символ Y находится в последовательности.

# Вариант 1

# f = open('24.txt')
# s = f.readline()
# print(s)

# s = open('24.txt').readline()
# print(s)
'''
with open('24.txt', 'r') as f:
    s = f.readline()
    # s = 'YYYYYOOOYYYYOOYYYYYYYYOYYYYYOYYY'

    count = 1
    maxi = 0
    for i in range(0, len(s)-1):
        if s[i] == 'Y' and s[i+1] == 'Y':
            count += 1
            maxi = max(maxi, count)
        else:
            count = 1
    print(maxi)
'''

# Вариант 2
'''
s = open('24.txt').readline().replace('X', ' ').replace('Z', ' ')
print(max([len(i) for i in s.split()]))

print(max([len(i) for i in open('24.txt').readline().replace('X', ' ').replace('Z', ' ').split()]))
'''
# Ответ: 10



# Тип 24 № 45258
# Текстовый файл состоит из символов A, B и C.
# Определите максимальное количество идущих подряд пар символов AB или CB в прилагаемом файле.
# Искомая подпоследовательность должна состоять только из пар AB, или только из пар CB,
# или только из пар AB и CB в произвольном порядке следования этих пар.
'''
s = open('24.txt').readline().replace('AB', '*').replace('CB', '*')
s = s.replace('A', ' ').replace('B', ' ').replace('C', ' ')
print(max([len(i) for i in s.split()]))
'''
# Ответ: 65


# Тип 24 № 27689
# Текстовый файл состоит не более чем из 10**6 символов X, Y и Z.
# Определите максимальную длину цепочки вида XYZXYZXYZ...
# (составленной из фрагментов XYZ, последний фрагмент может быть неполным).

# Проще проанализировать файл через поиск
'''
s = open('24.txt').readline().replace('XYZ', '***')
s = s.replace('X', ' ').replace('Y', ' ').replace('Z', ' ')
print(max([len(i) for i in s.split()]))
'''



# Тип 24 № 27421
'''
# Текстовый файл состоит не более чем из 10**6 символов X, Y и Z.
# Определите максимальное количество идущих подряд символов, среди которых каждые два соседних различны.
s = open('24.txt').readline()

count = 1
maxi = 0
for i in range(0, len(s)-1):
    if s[i] != s[i+1]:
        count += 1
        maxi = max(maxi, count)
    else:
        count = 1
print(maxi)
'''
# Ответ: 35


# Тип 24 № 36037
# Текстовый файл состоит не более чем из 1 200 000 символов X, Y, и Z.
# Определите максимальное количество идущих подряд символов, среди которых нет подстроки XZZY.
# Для выполнения этого задания следует написать программу.
# Ниже приведён файл, который необходимо обработать с помощью данного алгоритма.

# XZZYOOOOOOXZZY
# *ZZYOOOOOOXZZ*  на +6 больше
'''
s = open('24.txt').readline().replace('XZZY', ' ')
print(max([len(i) for i in s.split()]) + 6)
'''
# Ответ: 1713


D = {1:'один', 2:'two'}

# Тип 24 № 33526
'''
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите символ, который чаще всего встречается в файле между двумя одинаковыми символами.

import string
alphabet = string.ascii_uppercase  # ABCDEFGHIJKLMNOPQRSTUVWXYZ

s = open('24.txt').readline()
A = []
for i in range(0, len(s)-2):
    if s[i] == s[i+2]:
        A.append(s[i+1])
print(len(A))

my_dict = {}  # словарь dict()
for x in alphabet:
    my_dict[A.count(x)] = x

print(max(my_dict.items()))
'''
# Ответ: D



# Тип 24 № 33769
'''
# Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
# Определите символ, который чаще всего встречается в файле после двух одинаковых символов.

# import string
# alphabet = string.ascii_uppercase  # ABCDEFGHIJKLMNOPQRSTUVWXYZ

# alphabet = 'QWERTYUIOPASDFGHJKLZXCVBNM'

alphabet = sorted([i for i in 'QWERTYUIOPASDFGHJKLZXCVBNM'])
print(alphabet)

s = open('24.txt').readline()
A = []
for i in range(0, len(s)-2):
    if s[i] == s[i+1]:
        A.append(s[i+2])
print(len(A))

my_dict = {}  # словарь dict()
for x in alphabet:
    my_dict[A.count(x)] = x

print(max(my_dict.items()))
'''
# Ответ: K



# Тип 24 № 35913
'''
# Текстовый файл содержит строки различной длины. Общий объём файла не превышает 1 Мбайт.
# Строки содержат только заглавные буквы латинского алфавита (ABC…Z).
#
# Необходимо найти строку, содержащую наименьшее количество букв N
# (если таких строк несколько, надо взять ту, которая находится в файле раньше),
# и определить, какая буква встречается в этой строке чаще всего.
# Если таких букв несколько, надо взять ту, которая позже стоит в алфавите.

alphabet = sorted([i for i in 'QWERTYUIOPASDFGHJKLZXCVBNM'])

S = open('24.txt').readlines()
print(len(S))

mini = 99999
r = ''
for x in S:
    if mini > x.count('N'):
        mini = x.count('N')
        r = x
        print(r, mini)
print(r, mini)

my_dict = {}
for a in alphabet:
    my_dict[r.count(a)] = a
    # my_dict[a] = r.count(a)

print(my_dict)
print(max(my_dict.items()))
'''
# Ответ: Y


# endregion Урок: **********************************************************


# todo: Стася = [2, 5, 6, 8, 12, 14+, 15, 16, 17, 23, 25.2]
# на прошлом уроке: Разобрали простейшие номера 24 номера
# на следующем уроке: Продолжаем смотреть задачи на строки.

