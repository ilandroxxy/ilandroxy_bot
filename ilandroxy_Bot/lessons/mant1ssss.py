
# region Домашка: ******************************************************************

# КЕГЭ № 4869 (Уровень: Сложный)
# Алгоритм получает на вход натуральное число N > 1 и строит по нему новое число R следующим образом:
#
# 1. Строится двоичная запись числа N.
# 2. Вычисляется количество единиц, стоящих на чётных местах в двоичной записи числа N без ведущих нулей,
# и количество нулей, стоящих на нечётных местах.
# Места отсчитываются слева направо (от старших разрядов к младшим, начиная с единицы).
# 3. Результатом работы алгоритма становится модуль разности полученных двух чисел.
#
# Пример. Дано число N = 39. Алгоритм работает следующим образом:
# 1. Строится двоичная запись: 39_10 = 100111_2
# 2. Выделяем единицы на чётных и нули на нечётных местах: 100111
# На чётных местах стоят две единицы, на нечётных – один ноль.
# 3. Модуль разности равен 1
#
# Результат работы алгоритма R = 1
# При каком наименьшем N в результате работы алгоритма получится R = 5?

'''
for n in range(2, 10000):
    x = bin(n)[2:]

    kol_1 = len([i for i in range(0, len(x)) if x[i] == '1' and (i+1) % 2 == 0])
    kol_0 = len([i for i in range(0, len(x)) if x[i] == '0' and (i+1) % 2 != 0])

    r = abs(kol_0 - kol_1)

    if r == 5:
        print(n)
        break
'''

'''
for n in range(2, 10000+1):
    s = bin(n)[2:]  # 1. Строится двоичная запись числа N.
    count1 = 0
    count0 = 0
    for i in range(0, len(s)):
        if (i+1) % 2 == 0 and s[i] == '1':
            count1 += 1
        if (i+1) % 2 != 0 and s[i] == '0':
            count0 += 1

    r = abs(count0 - count1)  # # 3. Результатом работы алгоритма становится модуль разности полученных двух чисел.

    if r == 5:
        print(n)
        break
'''

'''
for n in range(1, 10000):
    x = bin(n)[2:]

    x = x.replace('0', 'a')
    x = x.replace('1', '0')
    x = x.replace('a', '1')

    x = '1' + x
    if x.count('1') % 2 == 0:
        x = x + '0'  # x += '0'
    else:
        x = x + '1'  # x += '1'
    R = int(x, 2)
    if R > 180:
        print(n)
        break
'''

# endregion Домашка: ******************************************************************


# region Урок: ******************************************************************

# Пишем свои функции в Пайтон
'''
def NOD(x, y):
    nod = 1
    for j in range(1, min(x, y)+1):
        if x % j == 0 and y % j == 0:
            nod = j
    return nod


print(NOD(16, 24))
'''


'''
print(max([1, 2, 3]))
print(sum([1, 2, 3]))

print(max(1, 2, 3))


def my_sum(*args):
    print(type(args))
    return sum(args)


print(my_sum(1, 2, 3))  # через *args мы можем принимать неограниченное кол-во аргументов в виде кортежа
'''

'''
def average_list(M: list) -> float:
    # M. прописывать типы данных нужно для того, чтобы работали методы
    return sum(M) / len(M)


print(average_list([1, 2, 3, 4, 5]))
'''

# Функция поиска Простого числа


# Функция поиска делителей числа


# Функция подсчета суммы цифр строки

# endregion Урок: ******************************************************************


# todo: Марк = [2.1, 6.1, 5.1, 8.1, 12.1, 14.1]
# todo: КЕГЭ  = []
# на прошлом уроке:
# на следующем уроке:
