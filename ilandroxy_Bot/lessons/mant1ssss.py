
# region Домашка: ******************************************************************

# КЕГЭ № 8953 Джобс 02.06.2023 (Уровень: Базовый) (Е. Джобс)
#
# Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
#
# F(n) = 1, если n≥10000
# F(n) = F(n+3) + 7, если n<10000 и четное
# F(n) = F(n+1) − 3, если n<10000 и нечетное
#
# Чему равно значение выражения F(50)−F(57)?
'''
import sys
sys.setrecursionlimit(5000)

def f(n):
    if n >= 10000:
        return 1
    if n < 10000 and n % 2 == 0:
        return f(n + 3) + 7
    if n < 10000 and n % 2 != 0:
        return f(n + 1) - 3

print(f(50) - f(57))

# f(50) = f(53) + 7
# f(53) = f(54) - 3
# f(54) = f(57) + 7 - f(57)

# 7 - 3 + 7 = 11
'''
# Ответ: 11


'''
x = int(input('x: '))
y = int(input('y: '))
try:
    print(x / y)
except ZeroDivisionError:
    print('На ноль делить нельзя!')
'''
'''
x = int(input('x: '))
y = int(input('y: '))
try:
    print(x / y)
except Exception as e:
    print(e)
'''

# КЕГЭ № 2248 (Уровень: Сложный)
#
# Алгоритм вычисления значения функции F(n), где n – целое число, задан следующими соотношениями:
#
# F(n) = n при n≤1
# F(n) = n + F(n/3) когда n>1 и делится на 3
# F(n) = n + F(n+3) когда n>1 и не делится на 3
#
# Назовите минимальное значение n, для которого F(n) определено и больше 100

'''
def F(n):
    if n <= 1:
        return n
    if n > 1 and n % 3 == 0:
        return n + F(n / 3)
    if n > 1 and n % 3 != 0:
        return n + F(n + 3)


for n in range(1, 10000):
    try:
        if F(n) > 100:
            print(n)
            break
    except RecursionError:
        ...
'''

# endregion Домашка: ******************************************************************


# region Урок: ******************************************************************

# Тип 15 №9321
# Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка
# на натуральное число m». Для какого наибольшего натурального числа А формула
#
# ¬ДЕЛ(x, А) → (¬ДЕЛ(x, 21) ∧¬ ДЕЛ(x, 35))
#
# тождественно истинна (то есть принимает значение 1 при любом натуральном значении переменной x)?
'''
# Вариант 1
def F(A, x):
    return (x % A != 0) <= ((x % 21 != 0) and (x % 35 != 0))

R = []
for A in range(1, 1000):
    flag = True
    for x in range(1, 10000):
        if F(A, x) == False:
            flag = False
            break
    if flag == True:
        R.append(A)
print(max(R))

# Вариант 2
def F(A, x):
    return (x % A != 0) <= ((x % 21 != 0) and (x % 35 != 0))

R = []
for A in range(1, 1000):
    if all(F(A, x) for x in range(1, 10000)):
        R.append(A)
print(max(R))

# Вариант 3
def F(A, x):
    return (x % A != 0) <= ((x % 21 != 0) and (x % 35 != 0))
print(max([A for A in range(1, 1000) if all(F(A, x) for x in range(1, 10000))]))

# Вариант 4
print(max([A for A in range(1, 1000) if all(((x % A != 0) <= ((x % 21 != 0) and (x % 35 != 0))) for x in range(1, 10000))]))
'''
# Ответ: 7


# Тип 15 №9804
# Обозначим через m & n поразрядную конъюнкцию неотрицательных целых чисел m и n.
# Так, например, 14 & 5 = 1110_2 & 0101_2 = 01002 = 4. Для какого наименьшего неотрицательного целого числа А формула
#
# x & 29 ≠ 0 → (x & 17 = 0 → x & А ≠ 0)
#
# тождественно истинна (т. е. принимает значение 1 при любом неотрицательном целом значении переменной x)?

# Вариант 1
def F(x, A):
    return (x & 29 != 0) <= ((x & 17 == 0) <= (x & A != 0))

for A in range(0, 1000):
    if all(F(x, A) for x in range(0, 10000)):
        print(A)
        break

# Вариант 2
def F(x, A):
    return (x & 29 != 0) <= ((x & 17 == 0) <= (x & A != 0))

print(min([A for A in range(0, 1000) if all(F(x, A) for x in range(0, 10000))]))

# endregion Урок: ******************************************************************


# todo: Марк = [2.1, 6.1, 5.1, 8.1, 12.1, 14.1, 16.1, 15.1, 23.1]
# todo: КЕГЭ  = []
# на прошлом уроке:
# на следующем уроке:
