
# region Домашка: ******************************************************************

# endregion Домашка: ******************************************************************


# region Урок: ******************************************************************
'''
print(bin(11)[2:])  # 1011
print(8 & 11)  # 8

ip = '192.45.234.2'  # 0 <= x <= 255: 32 бита: 4 байта по 1 байта или по 8 бит на число
ip_2 = '01010101.01010101.01010101.01010101'
print(bin(255)[2:])   # 11111111
print(bin(256)[2:])   # 100000000 - уже не помещается
'''

# Тип 13 №2238
# По заданным IP-адресу узла и маске определите адрес сети:
# IP-адрес: 145.92.137.88 Маска: 255.255.240.0
'''
IP = f'{bin(145)[2:]}.{bin(92)[2:].zfill(8)}.{bin(137)[2:]}.{bin(88)[2:].zfill(8)}'
print(IP)  # 10010001.1011100.10001001.1011000
'''

# Вариант 1
'''
IP = '.'.join(bin(x)[2:].zfill(8) for x in [145, 92, 137, 88])
MASK = '.'.join(bin(x)[2:].zfill(8) for x in [255, 255, 240, 0])
print(IP)

# Все маски имеют вид: сначала все единицы потом все нули
print(MASK)  # 11111111.11111111.11110000.00000000

NET = ''
for i in range(len(IP)):
    if IP[i] == '1' and MASK[i] == '1':
        NET += '1'
    elif IP[i] == '.':
        NET += '.'
    else:
        NET += '0'
print(NET)
NET = [int(s, 2) for s in '10010001.01011100.10000000.00000000'.split('.')]
print(NET)
'''
# Сопоставим варианты ответа получившимся числам: 145, 92, 128, 0.

# Вариант 2
'''
from ipaddress import *
net = ip_network('145.92.137.88/255.255.240.0', 0)
print(net)  # 145.92.128.0/20
'''
# Ответ: 145.92.128.0


# Тип 13 №3783
# Для некоторой подсети используется маска 255.255.255.128.
# Сколько различных адресов компьютеров теоретически допускает эта маска,
# если два адреса (адрес сети и широковещательный) не используют?
'''
from ipaddress import *
net = ip_network('0.0.0.0/255.255.255.128', 0)
print(net.num_addresses)  # Сколько различных адресов компьютеров
'''
# 128 - 2 = 126


# Тип 13 №3786
# Если маска подсети 255.255.240.0 и IP-адрес компьютера в сети 232.126.150.18, то номер компьютера в сети равен
'''
from ipaddress import *
net = ip_network('232.126.150.18/255.255.240.0', 0)
print(net)  # 232.126.144.0/20
ip1 = ip_address('232.126.150.18')
ip2 = ip_address('232.126.144.0')
print(int(ip1) - int(ip2))  # 1554
'''


# Тип 13 №25842
# Для узла с IP-адресом 111.81.224.27 адрес сети равен 111.81.192.0.
# Чему равен третий слева байт маски? Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'111.81.224.27/{mask}', 0)
    print(net.netmask, net)
    # 255.255.192.0  111.81.192.0/18
'''


# Тип 13 №16888
# Для узла с IP-адресом 98.162.71.94 адрес сети равен 98.162.71.64.
# Чему равно наименьшее количество возможных адресов в этой сети?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'98.162.71.94/{mask}', 0)
    print(net, net.num_addresses)
    # 98.162.71.64/26 64
    # 98.162.71.64/27 32
'''
# Ответ: 32.


# Тип 13 №18493
# Узлы с IP-адресами 98.162.71.151 и 98.162.71.155 находятся в одной сети.
# Чему равно наибольшее количество возможных единиц в маске этой сети?
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'98.162.71.151/{mask}', 0)
    net2 = ip_network(f'98.162.71.155/{mask}', 0)
    if net1 == net2:
        print(net1, net1.netmask)  # 98.162.71.144/28 255.255.255.240
'''
# Ответ: 28


# Тип 13 №13542
# Для узла с IP-адресом 136.128.196.48 адрес сети равен 136.128.192.0.
# Чему равно наибольшее возможное значение третьего слева байта маски?
# Ответ запишите в виде десятичного числа.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'136.128.196.48/{mask}', 0)
    print(net, net.netmask)
    # 136.128.192.0/18 255.255.192.0
    # 136.128.192.0/19 255.255.224.0
    # 136.128.192.0/20 255.255.240.0
    # 136.128.192.0/21 255.255.248.0
'''
# Ответ: 248


#
# № 11672 (Уровень: Базовый)
# (Л. Шастин) Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# — символ «?» означает ровно одну произвольную цифру;
# — символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.


# Среди натуральных чисел, не превышающих 10**10, найдите все числа, соответствующие маске 12*34?5,
# делящиеся на 21025 без остатка и состоящие из одинакового количества чётных и нечётных цифр.
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# а во втором столбце — соответствующие им результаты деления этих чисел на 21025.
# Количество строк в таблице для ответа избыточно.
'''
from fnmatch import *
for x in range(21025, 10**10, 21025):
    if fnmatch(str(x), '12*34?5'):
        # и состоящие из одинакового количества чётных и нечётных цифр.
        chet = [i for i in str(x) if i in '02468']
        nechet = [i for i in str(x) if i in '13579']
        if len(chet) == len(nechet):
            print(x, x // 21025)
'''
# Ответ:
# 1214803475 57779
# 1233263425 58657
# 1240033475 58979
# 1241673425 59057
# 1258493425 59857
# 1265263475 60179
# 1283723425 61057


# № 11667 (Уровень: Средний)
# (Л. Шастин) Текстовый файл состоит не более, чем из 10**7 прописных символов латинского алфавита.
# Определите в прилагаемом файле максимальное количество идущих подряд символов
# (длину непрерывной подпоследовательности), среди которых сочетание символов INFINITY встречается ровно 1000 раз.


# среди которых сочетание символов T встречается ровно 5 раз.
'''
print(len('0T0000T0000T000000T00000T00000'))
print(len('0000T0000T000000T00000T00000T000'))
print(len('0000T000000T00000T00000T000T000000'))

s = '0T0000T0000T000000T00000T00000T000T000000'.split('T')
print(s)  # ['0', '0000', '0000', '000000', '00000', '00000', '000', '000000']
maxi = 0
for i in range(0, len(s)-5, 1):
    maxi = max(maxi, len('T'.join(s[i:i+6])))
    # 1. '0T0000T0000T000000T00000T00000'
    # 2. '0000T0000T000000T00000T00000T000'
    # 3. '0000T000000T00000T00000T000T000000'
print(maxi)

'''

'''
s = open('24.txt').readline().split('INFINITY')
maxi = 0
for i in range(len(s)-1000):
    a = 'INFINITY'.join(s[i:i+1001])
    print(a.count('INFINITY'))
    maxi = max(maxi, len(a), a.count('INFINITY'))
print(maxi)
'''
# Ответ: 36733


# № 11671 (Уровень: Средний)
# (Л. Шастин) Исполнитель Акробат «живёт» на числовой оси. Система команд исполнителя:
#
# 1. Вперед 10 (Акробат прыгает вперед на 10 единиц),
# 2. Назад 5 (Акробат прыгает назад на 5 единиц) (отрицательные числа допускаются).
#
# Начальное положение Акробата - число 1. В скольких различных точках может оказаться Акробат после выполнения
# различных программ, которые содержат ровно 15 команд?
'''
M = []

def F(a, k):
    if k == 15:
        M.append(a)
        return 0
    return F(a+10, k+1) + F(a-5, k+1)

F(1, 0)
print(len(set(M)))
print(set(M))
'''
# Ответ: 16


# № 11703 (Уровень: Базовый)
# (Л. Шастин) В файле содержится последовательность целых чисел.
# Элементы последовательности могут принимать целые значения от -100 000 до 100 000 включительно.
# Определите количество троек элементов последовательности,
# в которых хотя бы один из трёх элементов является пятизначным числом,
# а произведение элементов тройки кратно максимальному элементу последовательности,
# оканчивающемуся на 18. В ответе запишите количество найденных троек чисел,
# затем максимальное из произведений элементов таких троек.
# В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.
'''
M = [int(x) for x in open('17.txt')]
A = [x for x in M if str(x)[-2:] == '18']
R = []
for i in range(len(M)-2):
    x, y, z = M[i], M[i+1], M[i+2]
    if len([len(str(abs(e))) == 5 for e in [x, y, z]]) > 0:
        if (x * y * z) % max(A) == 0:
            R.append(x * y * z)
print(len(R), max(R))
'''



# endregion Урок: ******************************************************************


# GOAL = [1.1, 2.1, 4.1, 5.1, 6.1, 8.1, 9.1, 12.1, 14.1, 15.1, 16.1, 17.1, 23.1, 24.1, 25.1]
# КЕГЭ  = []
# на следующем уроке:
