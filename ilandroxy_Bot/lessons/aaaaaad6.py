# region Домашка: ******************************************************************

# КЕГЭ № 5437 Джобс 21.12.22 (Уровень: Базовый)
#
# Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на натуральное число m».
# Найдите максимальное натуральное значение параметра А при котором выражение
#
# (ДЕЛ(z, 115) ∨  ДЕЛ(y, 78) ∨ ДЕЛ(х, 51)) → ДЕЛ(x , A)
#
# тождественно истинно (то есть принимает значение 1 при любых натуральных значений переменных х, y, z)?
'''
def F(x, y, z, A):
    return ((z % 115 == 0) or (y % 78 == 0) or (x % 51 == 0)) <= (x % A == 0)


R = []
for A in range(1, 1000):
    if all(F(x, y, z, A) for x in range(1, 100) for y in range(1, 100) for z in range(1, 100)):
        R.append(A)
print(max(R))
'''
# endregion Домашка: ******************************************************************


# region Урок: ******************************************************************
'''
import time
start = time.time()
"""
def divisors(x):  # 2.7965822219848633 
    div = []
    for j in range(1, x+1):  
        if x % j == 0:
            div.append(j)
    return div
"""


def divisors(x):  #
    div = []
    for j in range(1, int(x**0.5)+1):  # 0.0003
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


print(divisors(100_000_000))

end = time.time()
print(end-start)
'''


# Тип 25 №27856
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку
# [95632; 95650], числа, имеющие ровно шесть различных нечётных натуральных делителей
# (при этом количество четных делителей может быть любым).
# Для каждого найденного числа запишите эти шесть делителей в шесть соседних столбцов
# на экране с новой строки.
# Делители в строке должны следовать в порядке возрастания.
'''
def divisors(x):  #
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set([x for x in div if x % 2 != 0]))


for x in range(95632, 95650+1):
    d = divisors(x)
    if len(d) == 6:
        print(*d)
'''
# 1 3 9 10627 31881 95643
# 1 7 49 61 427 2989
# 1 5 25 1913 9565 47825


# Тип 25 №38603
# Пусть M — сумма минимального и максимального натуральных делителей целого числа,
# не считая единицы и самого числа. Если таких делителей у числа нет, то значение M считается равным нулю.
#
# Напишите программу, которая перебирает целые числа, бо́льшие 700000,
# в порядке возрастания и ищет среди них такие, для которых значение M оканчивается на 8.
# Выведите первые пять найденных чисел и соответствующие им значения M.
#
# Формат вывода: для каждого из пяти таких найденных чисел в отдельной строке
# сначала выводится само число, затем — значение М.
'''
def divisors(x):
    div = []
    for j in range(2, int(x**0.5)+1):  # не считая единицы и самого числа
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


k = 0
for x in range(700000+1, 1000000000):
    d = divisors(x)
    if len(d) > 2:
        M = min(d) + max(d)
        if M % 10 == 8:
            print(x, M)
            k += 1
            if k == 5:
                break
'''
# 700005 233338
# 700007 100008
# 700012 350008
# 700015 140008
# 700031 24168


# Тип 25 №27850
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [245690; 245756] простые числа.
# Выведите на экран все найденные простые числа в порядке возрастания, слева от каждого числа выведите его порядковый
# номер в последовательности. Каждая пара чисел должна быть выведена в отдельной строке.
'''
def divisors(x):  #
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


num = 1
for x in range(245690, 245756+1):
    d = divisors(x)
    if len(d) == 2:
        print(num, x)
    num += 1
'''
# 22 245711
# 30 245719
# 34 245723
# 52 245741
# 58 245747
# 64 245753


# Тип 25 №37160
# Найдите 5 чисел больших 500000, таких, что среди их делителей есть число, оканчивающееся на 8,
# при этом этот делитель не равен 8 и самому числу.
# В качестве ответа приведите 5 наименьших чисел, соответствующих условию.
'''
def divisors(x):
    div = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            if j != 8:
                div.append(j)
                div.append(x // j)
    return sorted(set([x for x in div if x % 10 == 8]))


k = 0
for x in range(500000+1, 10000000):
    d = divisors(x)
    if len(d) > 0:
        print(x, min(d))
        k += 1
        if k == 5:
            break
'''
# 500002 178
# 500004 18
# 500016 48
# 500018 58
# 500020 4348


# Тип 25 №33104
# Назовём нетривиальным делителем натурального числа его делитель, не равный единице и самому числу.
# Найдите все натуральные числа, принадлежащие отрезку [289123456; 389123456]
# и имеющие ровно три нетривиальных делителя.
# Для каждого найденного числа запишите в ответе его наибольший нетривиальный делитель.
'''
def divisors(x):
    div = []
    if x ** 0.5 == int(x ** 0.5):
        for j in range(2, int(x**0.5)+1):
            if x % j == 0:
                div.append(j)
                div.append(x // j)
    return sorted(set(div))


for x in range(289123456, 389123456+1):
    d = divisors(x)
    if len(d) == 3:
        print(x, max(d))
'''
# 294499921 2248091
# 352275361 2571353
# 373301041 2685619


# Тип 25 №48446
# Маска числа — это последовательность цифр, в которой могут встречаться специальные символы «?» и «*».
# Символ «?» означает ровно одну произвольную цифру,
# символ «*» означает произвольную (в том числе пустую) последовательность цифр.
#
# Найдите все натуральные числа, не превышающие 10**10, которые соответствуют маске 1?493*41
# и при этом без остатка делятся на 2023. В ответе запишите все найденные числа в порядке возрастания.
'''
from fnmatch import *
for x in range(2023, 10**10, 2023):  # и при этом без остатка делятся на 2023
    if fnmatch(str(x), '1?493*41'):
        print(x)
 '''
# 1349341
# 1249338041
# 1549348941
# 1849359841


# Тип 25 №59818
# — символ «?» означает ровно одну произвольную цифру;
# — символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Найдите все натуральные числа, не превосходящие 10**9, для которых выполнены все условия:
# — соответствуют маске *31*65?;
# — делятся на 31 и 2031 без остатка;
# — количество делителей числа является результатом любой степени двойки.
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# справа от каждого числа их частное от деления на 2031.


import time
start = time.time()
'''
from fnmatch import *

def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))



M = [2**i for i in range(1, 1000)]


for x in range(2031, 10**9, 2031):
    if x % 31 == 0:
        if fnmatch(str(x), '*31*65?'):
            if len(divisors(x)) in M:
                print(x, x // 2031)
'''
# 53831655 26505
# 333126651 164021
# 512313657 252247
# 647931651 319021
# 831966654 409634

end = time.time()
print(end - start)

# endregion Урок: ******************************************************************


# Лера = [2.1, 5.1, 6.1, 8.1, 12.1, 14.1. 15.1, 16.1, 23.1, 25.1]
# КЕГЭ  = []
# на следующем уроке:
