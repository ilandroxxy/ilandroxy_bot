
# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************



# region Урок: ******************************************************************

# Тип 5 № 10282 i
# Автомат получает на вход пятизначное число.
# По этому числу строится новое число по следующим правилам.
#
# 1. Складываются отдельно первая, третья и пятая цифры, а также вторая и четвёртая цифры.
# 2. Полученные два числа записываются друг за другом в порядке неубывания без разделителей.
#
# Пример. Исходное число: 63 179. Суммы: 6 + 1 + 9 = 16; 3 + 7 = 10. Результат: 1016.
#
# Укажите наименьшее число, при обработке которого автомат выдаёт результат 723.
'''
for n in range(10000, 100000):
# for n in range(63179, 63179+1):
    M = [int(i) for i in str(n)]

    a = M[0] + M[2] + M[4]
    b = M[1] + M[3]

    r = str(min(a, b)) + str(max(a, b))

    if r == '723':
        print(n)
        exit()
    '''
# Ответ: 50979


# Тип 5 № 10380 i
# Автомат получает на вход четырёхзначное число. По этому числу строится новое число по следующим правилам.
#
# 1. Складываются отдельно первая и вторая цифры, вторая и третья цифры, а также третья и четвёртая цифры.
# 2. Из полученных трёх чисел выбираются два наибольших и записываются друг за другом в порядке неубывания без разделителей.
#
# Пример. Исходное число: 9575. Суммы: 9 + 5 = 14; 5 + 7 = 12; 7 + 5 = 12. Наибольшие суммы: 14, 12. Результат: 1214.
# Укажите наибольшее число, при обработке которого автомат выдаёт результат 1517.
'''
for n in range(1000, 10000):
    M = [int(i) for i in str(n)]

    a = M[0] + M[1]
    b = M[1] + M[2]
    c = M[2] + M[3]

    maxi = max(a, b, c)
    mini = min(a, b, c)
    sred = (a + b + c) - maxi - mini

    r = str(sred) + str(maxi)

    if r == '1517':
        print(n)
'''

'''
for n in range(10000-1, 1000-1, -1):
    M = [int(i) for i in str(n)]

    a = M[0] + M[1]
    b = M[1] + M[2]
    c = M[2] + M[3]

    maxi = max(a, b, c)
    mini = min(a, b, c)
    sred = (a + b + c) - maxi - mini

    r = str(sred) + str(maxi)

    if r == '1517':
        print(n)
        break
'''

'''
for n in range(10000-1, 1000-1, -1):
    M = [int(i) for i in str(n)]

    a = M[0] + M[1]
    b = M[1] + M[2]
    c = M[2] + M[3]
    
    # Вариант 1
    # A = sorted([a, b, c])
    
    # Вариант 2
    
    A = [a, b, c]
    A.sort()
    r = str(A[1]) + str(A[2])  # A[0] было минимальным

    if r == '1517':
        print(n)
        break
'''

'''
for n in range(10000 - 1, 1000 - 1, -1):
    M = [int(i) for i in str(n)]

    A = sorted([M[0] + M[1], M[1] + M[2], M[2] + M[3]])
    r = str(A[1]) + str(A[2])  # A[0] было минимальным

    if r == '1517':
        print(n)
        break
'''
# Ответ: 9878



# Тип 5 № 10495 i
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#
# 1. Строится двоичная запись числа N.
# 2. К этой записи дописываются справа ещё два разряда по следующему правилу:
# а) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа).
# б) над этой записью производятся те же действия — справа дописывается остаток от деления суммы цифр на 2.

# Укажите такое наименьшее число N, для которого результат работы алгоритма больше 97.
# В ответе это число запишите в десятичной системе счисления.
'''
for n in range(1, 10000):
    temp = n
    M = []
    while n > 0:
        M.append(n % 2)
        n //= 2
    M.reverse()

    for _ in range(2):
        M.append(sum(M) % 2)

    r = 0
    M.reverse()
    for i in range(0, len(M)):
        r += M[i] * 2 ** i

    if r > 97:
        print(temp)
        break
'''


'''
for n in range(1, 10000):
    s = bin(n)[2:]

    for _ in range(2):
        s += str(s.count('1') % 2)
        # s = str(s.count('1') % 2) + s  # добавление слева
    r = int(s, 2)

    if r > 97:
        print(n)
        break
'''

# Универсальная функция
'''
def my_bin(x, n):
    alphabet = '0123456789abcdef'
    M = []
    while x > 0:
        M.append(alphabet[x % n])
        x //= n
    M.reverse()
    return ''.join(M)
'''

'''
def my_bin(x, n):
    alphabet = '0123456789abcdef'
    M = []
    while x > 0:
        M.append(alphabet[x % n])
        x //= n
    M.reverse()
    return ''.join(M)

for n in range(1, 10000):
    s = my_bin(n, 2)

    for _ in range(2):
        s += str(s.count('1') % 2)
        # s = str(s.count('1') % 2) + s  # добавление слева
    r = int(s, 2)

    if r > 97:
        print(n)
        break
'''
# Ответ: 25

# class my_string(str):
#
#     def add1(self):
#         r.
#         return r


# Тип 5 № 45239 i
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#
# 1. Строится двоичная запись числа N.
# 2. Далее эта запись обрабатывается по следующему правилу:
# а) если число чётное, то к двоичной записи числа слева дописывается 10;
# б)  если число нечётное, то к двоичной записи числа слева дописывается 1 и справа дописывается 01.
#
# Полученная таким образом запись является двоичной записью искомого числа R.

# Укажите минимальное число N, после обработки которого с помощью этого алгоритма получается число R, большее, чем 441.
# В ответе запишите это число в десятичной системе счисления.
'''
for n in range(1, 100000):
    s = bin(n)[2:]

    if n % 2 == 0:
        s = '10' + s
    else:
        s = '1' + s + '01'

    r = int(s, 2)

    if r > 441:
        print(n)
        break
'''
# Ответ: 47

# Тип 5 № 29113 i
# Автомат обрабатывает натуральное число N (128 ≤ N ≤ 255) по следующему алгоритму:
#
# 1. Строится восьмибитная двоичная запись числа N.
# 2. Все цифры двоичной записи заменяются на противоположные (0 на 1, 1 на 0).
# 3. Полученное число переводится в десятичную запись.
# 4. Из исходного числа вычитается полученное, разность выводится на экран.
#
# Какое число нужно ввести в автомат, чтобы в результате получилось 185?
'''
for n in range(128, 255+1):
    s = bin(n)[2:]

    s = s.replace('0', '*')
    s = s.replace('1', '0')
    s = s.replace('*', '1')

    r = int(s, 2)

    res = n - r

    if res == 185:
        print(n)
'''
# Ответ: 220


# Тип 8 № 3696 i
# Все 5-буквенные слова, составленные из букв В, И, Н, Т, записаны в алфавитном порядке.
# Вот начало списка:
# 1. ВВВВВ
# 2. ВВВВИ
# 3. ВВВВН
# 4. ВВВВТ
# 5. ВВВИВ
#
# Запишите слово, которое стоит под номером 1020.
'''
s = sorted(['В', 'И', 'Н', 'Т'])
# s = 'ВИНТ'
k = 1
for a in s:  # 4
    for b in s:  # 4 * 4
        for c in s:  # 4 * 4 * 4
            for d in s:  # 4**4
                for e in s:  # 4**5  = 1024
                    temp = a + b + c + d + e
                    if k == 1020:
                        print(k, temp)
                    k += 1
'''
'''
s = sorted(['В', 'И', 'Н', 'Т'])
M = [0]
for a in s:  # 4
    for b in s:  # 4 * 4
        for c in s:  # 4 * 4 * 4
            for d in s:  # 4**4
                for e in s:  # 4**5  = 1024
                    temp = a + b + c + d + e
                    M.append(temp)

print(M[1020])
'''
# Ответ: ТТТНТ


# Тип 8 № 13513
# Игорь составляет таблицу кодовых слов для передачи сообщений, каждому сообщению соответствует своё кодовое слово.
# В качестве кодовых слов Игорь использует 6-буквенные слова, в которых есть только буквы A, B, X, причём буква X появляется ровно 1 раз.
# Каждая из букв A, B может встречаться в кодовом слове любое количество раз или не встречаться совсем.
# Сколько различных кодовых слов может использовать Игорь?
'''
s = 'ABX'
count = 0
for a in s:
    for b in s:
        for c in s:
            for d in s:
                for e in s:
                    for f in s:
                        temp = a + b + c + d + e + f
                        if temp.count('X') == 1:
                            count += 1
print(count)
'''

'''
import itertools
count = 0
s = itertools.product("ABX", repeat=6)
for temp in s:
    temp = ''.join(temp)
    if temp.count('X') == 1:
        count += 1
print(count)
'''


# Тип 8 № 27379
# Виктор составляет 4-буквенные коды из букв В, И, К, Т, О, Р.
# Каждую букву можно использовать не более одного раза, при этом нельзя ставить рядом две гласные и две согласные.
# Сколько различных кодов может составить Виктор?
'''
s = 'ВИКТОР'
s1 = 'ВКТР'
s2 = 'ИО'
count = 0
for a in s1:
    for b in s2:
        for c in s1:
            for d in s2:
                temp = [a, b, c, d]
                if len(set(temp)) == len(temp):
                    count += 1
"""         
for a in s2:
    for b in s1:
        for c in s2:
            for d in s1:
                temp = [a, b, c, d]
                if len(set(temp)) == len(temp):
                    count += 1
"""
print(count * 2)
'''


# Тип 8 № 26953
# Найдите количество пятизначных восьмеричных чисел,
# в которых все цифры различны и никакие две четные или нечетные не стоят рядом.
'''
s = '01234567'
s1 = '1357'
s2 = '0246'
count = 0
for a in s1:
    for b in s2:
        for c in s1:
            for d in s2:
                for e in s1:
                    temp = [a, b, c, d, e]
                    if len(set(temp)) == len(temp):
                        count += 1
for a in '246':
    for b in s1:
        for c in s2:
            for d in s1:
                for e in s2:
                    temp = [a, b, c, d, e]
                    if len(set(temp)) == len(temp):
                        count += 1
print(count)
'''

# endregion Урок: ******************************************************************


# todo: Сергей = [2, 5, 8, 14]
# на прошлом уроке: Разобрали 5, 8 номера всех типов
# на следующем уроке: Повторяем 5, 8, Разбираем 12. Функции 16, 23
