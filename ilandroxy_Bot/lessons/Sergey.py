
# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************


# region Урок: ******************************************************************

# Тип 8 № 26953
# Найдите количество пятизначных восьмеричных чисел,
# в которых все цифры различны и никакие две четные или нечетные не стоят рядом.

'''
import itertools as it

M = []
for s in it.permutations('01234567', 2):
    if int(s[0]) % 2 == int(s[1]) % 2:
        pair = ''.join(s)
        M.append(pair)

count = 0
for s in it.permutations('01234567', 5):
    if s[0] != '0':
        slovo = ''.join(s)
        print(slovo, [slovo[x] + slovo[x+1] for x in range(0, len(slovo)-1)])
        if all(i not in slovo for i in M):
            count += 1
print(count)
'''

'''
import itertools as it

M = []
for s in it.permutations('01234567', 2):
    if int(s[0]) % 2 != int(s[1]) % 2:
        pair = ''.join(s)
        M.append(pair)
print(M)

count = 0
for s in it.product('01234567', repeat=5):
    if s[0] != '0' and len(set(s)) == len(s):
        slovo = ''.join(s)
        print(slovo, [slovo[x] + slovo[x+1] for x in range(0, len(slovo)-1)])
        if all(i in M for i in [slovo[x] + slovo[x+1] for x in range(0, len(slovo)-1)]):
            print(slovo)
            count += 1
print(count)
'''


# Вариант 1
'''
s = '01234567'
s1 = '1357'
s2 = '0246'
count = 0

for a in s1:
    for b in s2:
        for c in s1:
            for d in s2:
                for e in s1:
                    temp = a + b + c + d + e
                    if len(set(temp)) == len(temp):  # или 5
                        count += 1

for a in '246':
    for b in s1:
        for c in s2:
            for d in s1:
                for e in s2:
                    temp = a + b + c + d + e
                    if len(set(temp)) == len(temp):  # или 5
                        count += 1

print(count)
'''

'''
s = '01234567'
s1 = '1357'
s2 = '0246'

# первый вариант
temp1 = [a + b + c + d + e for a in s1 for b in s2 for c in s1 for d in s2 for e in s1 if len(set(a + b + c + d + e)) == 5]
# второй вариант
temp2 = [a + b + c + d + e for a in '246' for b in s1 for c in s2 for d in s1 for e in s2 if len(set(a + b + c + d + e)) == 5]

# объединяем списки
temp = temp1 + temp2

# считаем количество уникальных элементов
count = len(temp)

print(count)
'''


# Тип 15 № 15955
# На числовой прямой задан отрезок A. Известно, что формула
#
# ((x ∈ A) → (x**2 ≤ 81)) ∧ ((y**2 ≤ 36) → (y ∈ A))
#
# тождественно истинна при любых вещественных x и y.
# Какую наименьшую длину может иметь отрезок A?

# a = set(range(-1000, 1000))
#
# def F(x, y):
#     return ((x in a) <= (x**2 <= 81)) and ((y**2 <= 36) <= (y in a))
#
# for x in range(-100, 100):
#     for y in range(-100, 100):
#         if F(x, y) == False:
#             a.remove(x)


# № 4283 (Уровень: Средний)
# Элементами множеств А, P, Q являются натуральные числа, причём P={1,3,4,9,11,13,15,17,19,21},
# Q={3,6,9,12,15,18,21,24,27,30}. Известно, что выражение
#
# ((x ∈ P) → (x ∈ A)) ∨ ((x ∉ A) → (x ∉ Q))
#
# истинно (т.е. принимает значение 1 при любом значении переменной х.
# Определите наименьшее возможное произведение элементов в множестве A.
'''
a = set()

def F(x):
    P = x in {1, 3, 4, 9, 11, 13, 15, 17, 19, 21}
    Q = x in {3, 6, 9, 12, 15, 18, 21, 24, 27, 30}
    A = x in a
    return (P <= A) or ((not A) <= (not Q))

for x in range(-1000, 1000):
    if F(x) == False:
        a.add(x)
print(a)
print(9 * 3 * 21 * 15)
'''

#
# № 3156 (Уровень: Средний)
# Элементами множеств А, P и Q являются натуральные числа, причём P = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
# и Q = { 5, 10, 15, 20, 25, 30, 35, 40, 45, 50}. Известно, что выражение
#
# ((x ∈ A) → (x ∈ P)) ∧ ((x ∈ Q) → ¬(x ∈ A))
#
# истинно (т. е. принимает значение 1) при любом значении переменной х.
# Определите наибольшее возможное количество элементов множества A.
'''
a = set(range(-1000, 1000))

def F(x):
    P = x in {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
    Q = x in {5, 10, 15, 20, 25, 30, 35, 40, 45, 50}
    A = x in a
    return (A <= P) and (Q <= (not A))

for x in range(-1000, 1000):
    if F(x) == False:
        a.remove(x)

print(a, len(a))
'''
# Ответ: 8


# Тип 15 № 11119
# На числовой прямой даны два отрезка: P = [20, 50] и Q = [30,65]. Отрезок A таков, что формул
#
# ¬(x ∈ A) → ((x ∈ P) →¬ (x ∈ Q))
#
# истинна при любом значении переменной x. Какова наименьшая возможная длина отрезка A?
'''
def F(x, a1, a2):
    # P = 20 <= x <= 50
    P = x in range(20, 50+1)
    Q = 30 <= x <= 65
    A = a1 <= x <= a2
    return (not A) <= (P <= (not Q))
    # return (not(a1 <= x <= a2)) <= ((20 <= x <= 50) <= (not(30 <= x <= 65)))


R = []
M = [i / 3 for i in range(10 * 3, 70 * 3)]
print(M)
for a1 in M:
    for a2 in M:
        if all(F(x, a1, a2) for x in M):
            R.append(a2-a1)

print(min(R))
'''

# Тип 25 № 35483
# Найдите все натуральные числа, принадлежащие отрезку [35000000;40000000],
# у которых ровно пять различных нечётных делителей (количество чётных делителей может быть любым).
# В ответе перечислите найденные числа в порядке возрастания.
'''
def Divisors(x):
    divisors = set()
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            if j % 2 != 0:
                divisors.add(j)
            if (x // j) % 2 != 0:
                divisors.add(x // j)
            if len(divisors) > 5:
                return sorted(divisors)
    return sorted(divisors)

for x in range(35000000, 40000000+1):
    divisors = Divisors(x)
    if len(divisors) == 5:
        print(x)
'''
# Ответ:
# 35819648
# 38950081
# 39037448
# 39337984


# Тип 25 № 29673
# Найдите все натуральные числа, принадлежащие отрезку [123456789; 223456789]
# и имеющие ровно три нетривиальных делителя.
# Для каждого найденного числа запишите в ответе его наибольший нетривиальный делитель.
# Ответы расположите в порядке возрастания.
'''
def Divisors(x):
    divisors = set()
    if round(x ** 0.5) == (x **0.5):
        for j in range(2, int(x**0.5)+1):
            if x % j == 0:
                divisors.add(j)
                divisors.add(x // j)
    return sorted(divisors)

for x in range(123456789, 223456789+1):
    divisors = Divisors(x)
    if len(divisors) == 3:
        print(x, max(divisors))
'''
# Ответ:
# 131079601 1225043
# 141158161 1295029
# 163047361 1442897


# Тип 24 № 35482

# Необходимо найти строку, содержащую наименьшее количество букв G
# (если таких строк несколько, надо взять ту, которая находится в файле раньше),
# и определить, какая буква встречается в этой строке чаще всего.
# Если таких букв несколько, надо взять ту, которая позже стоит в алфавите.
#

# В этом примере в первой строке две буквы G, во второй и третьей— по одной.
# Берём вторую строку, т. к. она находится в файле раньше.
# В этой строке чаще других встречаются буквы A и B (по два раза), выбираем букву B,
# т. к. она позже стоит в алфавите. В ответе для этого примера надо записать B.
#
# Для выполнения этого задания следует написать программу.
# Ниже приведён файл, который необходимо обработать с помощью данного алгоритма.
'''
ALPHABET = sorted('QWERTYUIOPASDFGHJKLZXCVBNM')
s = open('24.txt').readlines()
mini = 999999
maxi = 0
r = ''
for x in s:
    if mini > x.count('G'):
        mini = x.count('G')
        r = x


for a in ALPHABET:
    if maxi <= r.count(a):
        maxi = r.count(a)
        print(a, maxi)
'''
# Ответ: T

# endregion Урок: ******************************************************************


# todo: Сергей = [1, 2, 3, 5, 8, 7.1, 9, 12, 14, 15, 16, 17, 18, 19-21, 22, 23, 24, 25]
# на прошлом уроке: Разбирали 18 номера всех типов.
# на следующем уроке: Повторить 18 номер и можно чуть-чуть порешать базовые 26 номера
