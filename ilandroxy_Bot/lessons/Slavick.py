# region Домашка: ******************************************************************

# КЕГЭ № 2248 (Уровень: Сложный)
#
# Алгоритм вычисления значения функции F(n), где n – целое число, задан следующими соотношениями:
#
# F(n) = n при n≤1
# F(n) = n + F(n/3) когда n>1 и делится на 3
# F(n) = n + F(n+3) когда n>1 и не делится на 3
#
# Назовите минимальное значение n, для которого F(n) определено и больше 100
'''
import sys
sys.setrecursionlimit(10000)

def F(n):
    if n <= 1:
        return n
    if n > 1 and n % 3 == 0:
        return n + F(n / 3)
    if n > 1 and n % 3 != 0:
        return n + F(n + 3)


for n in range(1, 1000):
    try:
        if F(n) > 100:
            print(n)
            break
    except Exception as e:
        print(n, f'Ошибка: {e}')
        continue
'''
# endregion Домашка: ******************************************************************


# region Урок: ********************************************************************
'''
while True:
    try:
        a = int(input('a: '))
        s = input('s: ')
        b = int(input('b: '))
        if s == '+':
            print(f'{a} + {b} = {a + b}')
        elif s == '-':
            print(f'{a} - {b} = {a - b}')
        elif s == '*':
            print(f'{a} * {b} = {a * b}')
        elif s == '/':
            print(f'{a} / {b} = {a / b}')
    except Exception as e:
        print(f'Ошибка: {e}')
'''


# ЗАДАЧИ С ДЕЛИТЕЛЯМИ
"""
import time
start = time.time()
'''
def divisors(x):
    div = []
    for j in range(1, x+1):
        if x % j == 0:
            div.append(j)
    return div


print(divisors(100_000_000))  # 2.928690195083618
'''


# [1, 2, int(16 ** 0.5), 8, 16]  - если у числа есть целый квадратный корень, то нечетное кол-во делителей
# [1, 2, 3, 4, int(24 ** 0.5), 6, 8, 12, 24]  - иначе четное кол-во делителей
# через элемент слева, можем достать его сомножитель: 24 // 4 = 6, 24 // 6 = 4

def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


print(divisors(100_000_000))  # 0.0003


end = time.time()
print(end - start)


print(divisors(24))  # [1, 2, 3, 4, 6, 8, 12, 24]
print(divisors(16))  # [1, 2, 4, 4, 8, 16]
"""


# Тип 25 №33770
# Найдите все натуральные числа, принадлежащие отрезку [106000000; 107000000],
# у которых ровно три различных чётных делителя.
# В ответе перечислите найденные числа в порядке возрастания.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


for x in range(106000000, 107000000+1):
    div = [a for a in divisors(x) if a % 2 == 0]
    if len(div) == 3:
        print(x)
'''
# Ответ:
# 106084178
# 106492418
# 106784498
# 106842962


# Тип 25 №27850
# Напишите программу, которая ищет среди целых чисел, принадлежащих
# числовому отрезку [245690; 245756] простые числа.
# Выведите на экран все найденные простые числа в порядке возрастания,
# слева от каждого числа выведите его порядковый номер в последовательности.
# Каждая пара чисел должна быть выведена в отдельной строке.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


num = 1
for x in range(245690, 245756+1):
    div = divisors(x)
    if len(div) == 2:
        print(num, x)
    num += 1
 '''
# Ответ:
# 22 245711
# 30 245719
# 34 245723
# 52 245741
# 58 245747
# 64 245753


# Тип 25 №47022
# Пусть M(N) — пятый по величине делитель натурального числа N без учёта самого числа и единицы.
#
# Если у числа N меньше 5 различных делителей, не считая единицы и самого числа, считаем,
# что M(N)=0.
#
# Найдите 5 наименьших натуральных чисел, превышающих 300000000, для которых M(N) > 0.
# В ответе запишите найденные значения M(N) в порядке возрастания соответствующих им чисел N.
'''
def divisors(x):
    div = []
    for j in range(2, int(x**0.5)+1):  # без учёта самого числа и единицы
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


k = 0
for x in range(300000000+1, 3000000000000):
    div = divisors(x)
    if len(div) >= 5:
        M = div[-5]
        print(M)
        k += 1
        if k == 5:
            break
'''
# Ответ:
# 17
# 1119403
# 151
# 16666667
# 27272728


# ЗАДАЧИ С МАСКАМИ

# Тип 25 №58492
# Маска числа — это последовательность цифр, в которой могут встречаться специальные символы «?» и «*».
# Символ «?» означает ровно одну произвольную цифру,
# символ «*» означает произвольную (в том числе пустую) последовательность цифр.
#
# Маске 123*4?5 соответствуют числа 123405 и 12300002415.
#
# Найдите все натуральные числа, не превышающие 10**10, которые соответствуют маске 1?7602*0
# и при этом без остатка делятся на 4891. В ответе запишите все найденные числа в порядке возрастания.
'''
print(10**10)
print('1?7602***0')
'''
'''
# Вариант 1
from itertools import product
for l in range(0, 3+1):
    for s in product('0123456789', repeat=l):  # *
        y = ''.join(s)
        for x in '0123456789':  # ?
            num = f'1{x}7602{y}0'
            if int(num) % 4891 == 0:
                print(num)

# Вариант 2
from fnmatch import *
for x in range(4891, 10**10, 4891):
    if fnmatch(str(x), '1?7602*0'):
        print(x)
'''
# Ответ:
# 1076020
# 10760200
# 107602000
# 1076020000
# 1576026930


# № 12932 PRO100 ЕГЭ 26.01.24 (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#     – символ «?» означает ровно одну произвольную цифру;
#     – символ «*» означает любую последовательность цифр произвольной длины;
#     в том числе «*» может задавать и пустую последовательность.
#
# Среди натуральных чисел, не превышающих 10**10, найдите все числа, соответствующие маске 1?2*4,
# делящиеся на 2024 без остатка и являющиеся полными квадратами.
#
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания,
# а во втором столбце – соответствующие им результаты деления этих чисел на 2024.
'''
from fnmatch import *
for x in range(2024, 10**10, 2024):
    if fnmatch(str(x), '1?2*4'):
        if x ** 0.5 == int(x ** 0.5):
            print(x, x // 2024)
'''
# Ответ:
# 1024144 506
# 1327290624 655776
# 1721586064 850586


# № 6210 (Уровень: Средний)
# (Н. Сафронов) Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# — символ «?» означает ровно одну произвольную цифру;
# — символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
#
# Найдите все натуральные числа, не превосходящие 10**7, для которых выполняются одновременно все условия:
#
# • соответствуют маске *2?2*;
# • являются палиндромами;
# • делятся на число 53 без остатка;
# • количество делителей больше 30.
#
# В ответе запишите в первом столбце таблицы все найденные числа
# в порядке возрастания, а во втором столбце — сумму делителей.
'''
from fnmatch import *

def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


for x in range(53, 10**7, 53):
    if fnmatch(str(x), '*2?2*'):
        if str(x) == str(x)[::-1]:
            div = divisors(x)
            if len(div) > 30:
                print(x, sum(div))
'''
# Ответ:
# 212212 508032
# 2527252 5588352
# 4282824 13789440
# 4626264 11787120
# 8125218 19595520
# 8824288 19908504

# endregion Урок: *************************************************************


# Славик = [2.1, 5.1, 6.1, 8.1, 9.1, 12.1, 14.1, 15.1, 16.1, 23.1, 25.1]
# КЕГЭ  = []
# на следующем уроке:
