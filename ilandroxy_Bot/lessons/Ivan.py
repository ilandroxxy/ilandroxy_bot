# region Домашка: ******************************************************************************


# endregion Домашка: ******************************************************************************


# region Урок: ******************************************************************************

# Повтори 2 [Вперёд 10 Направо 90 Вперёд 20 Направо 90]
# Поднять хвост
# Вперёд 3 Направо 90 Вперёд 5 Налево 90
# Опустить хвост
# Повтори 2 [Вперёд 70 Направо 90 Вперёд 80 Направо 90]

# Определите, сколько точек с целочисленными координатами будут
# находиться внутри пересечения фигур, ограниченных заданными
# алгоритмом линиями, включая точки на границах этого пересечения.

'''
import turtle as t
t.left(90)
t.speed(10)
l = 5
t.color('red')

t.begin_fill()
for _ in range(2):
    t.forward(10*l)
    t.right(90)
    t.forward(20*l)
    t.right(90)
t.end_fill()

t.pu()
t.forward(3*l)
t.right(90)
t.forward(5*l)
t.left(90)
t.pd()

t.begin_fill()
for _ in range(2):
    t.forward(70*l)
    t.right(90)
    t.forward(80*l)
    t.right(90)
t.end_fill()

canvas = t.getcanvas()
count = 0
for x in range(-100*l, 100*l, l):
    for y in range(-100 * l, 100 * l, l):
        item = canvas.find_overlapping(x, y, x, y)
        if len(item) >= 1 and item[0] == 5:
            count += 1
print(count)

t.done()
'''

'''
import turtle as t
t.left(90)
t.speed(10)
l = 20
t.color('red')

for _ in range(2):
    t.forward(10*l)
    t.right(90)
    t.forward(20*l)
    t.right(90)

t.pu()
t.forward(3*l)
t.right(90)
t.forward(5*l)
t.left(90)
t.pd()

for _ in range(2):
    t.forward(70*l)
    t.right(90)
    t.forward(80*l)
    t.right(90)

t.pu()
t.color('blue')
for x in range(0, 22):
    for y in range(0, 12):
        t.goto(x*l, y*l)
        t.dot(2)
t.done()
'''

# Тип 16 Статград
'''
# Вариант 1
print(1_134_567_00 - 237_567_89+1)

# Вариант 2
print(len([i for i in range(237_567_899, 1_134_567_009+1, 10)]))

# Вариант 3
count = 0
for x in range(237_567_899, 1_134_567_009+1, 10):
    count += 1
print(count)
'''
# Ответ: 89699912

# Тип 8
'''
# Определите количество пятизначных чисел, записанных в восьмеричной
# системе счисления, в записи которых только одна цифра 6, при этом никакая
# нечётная цифра не стоит рядом с цифрой 6.

s = '01234567'
M = ['16', '61', '36', '63', '56', '65', '76', '67']
count = 0
for a in '1234567':
    for b in s:
        for c in s:
            for d in s:
                for e in s:
                    temp = a + b + c + d + e
                    flag = True
                    if temp.count('6') == 1:
                        for x in M:
                            if x in temp:
                                flag = False
                        if flag == True:
                            print(temp)
                            count += 1
print(count)
'''
# Ответ: 2961

'''
# При регистрации в компьютерной системе каждому объекту присваивается
# идентификатор, состоящий из 250 символов и содержащий только
# десятичные цифры и символы из 1650-символьного специального алфавита.
# В базе данных для хранения каждого идентификатора отведено одинаковое
# и минимально возможное целое число байт.  При этом используется
# посимвольное кодирование идентификаторов, все символы кодируются
# одинаковым и минимально возможным количеством бит.
# Определите объём памяти (в Кбайт), необходимый для хранения 65 536
# идентификаторов.  В ответе запишите только целое число – количество
# Кбайт.

symbols = 250
alphabet = 10 + 1650
# alphabet = 2**i
print(2**11, alphabet)  # i не может быть меньше чем alphabet
i = 11
bit = symbols * i  # 2750 бит информации на один ID пользователя
print(bit)

byte = int(bit / 8)+1  # округляем байты вверх, чтобы не потерять информацию
print(byte)  # уходит байт на хранение одного ID пользователя


K_byte = (65_536 * byte) / (2**10)
print(K_byte)  # 22016 Кбайт уходи на хранение всех ID-шников
'''
# Ответ: 22016


# Тип 5
'''
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
# 1. Строится двоичная запись числа N.
# 2. Далее эта запись обрабатывается по следующему правилу:
# а) если сумма цифр в двоичной записи числа чётная, то к этой записи
# справа дописывается 0, а затем два левых разряда заменяются на 10;
# б) если сумма цифр в двоичной записи числа нечётная, то к этой записи
# справа дописывается 1, а затем два левых разряда заменяются на 11.
# Полученная таким образом запись является двоичной записью искомого числа R.

# Укажите минимальное число N, после обработки которого с помощью
# этого алгоритма получается число R, большее 40. В ответе запишите это
# число в десятичной системе счисления.

for n in range(1, 1000):
    s = bin(n)[2:]  # 1. Строится двоичная запись числа N. (срезаются первые два символа)

    if s.count('1') % 2 == 0:  # а) если сумма цифр в двоичной записи числа чётная
        s += '0'  # то к этой записи справа дописывается 0
        s = '10' + s[2:]  # а затем два левых разряда заменяются на 10;
    else:
        s += '1'  # то к этой записи справа дописывается 1
        s = '11' + s[2:]  # а затем два левых разряда заменяются на 11.

    r = int(s, 2)  # перевод из 2-ной в 10-ную
    if r > 40:
        print(n)  # первое найденное n и будет минимальным
        break
'''


# endregion Урок: ******************************************************************************


# todo: Иван = [2, 6, 8, 10, 12, 13, 14+, 15+, 16, 17, 23]
# на прошлом уроке: Разобрали несколько задач с ФИПИ пробника
# на следующем уроке: Посмотреть 16 номера с КЕГЭ, 5 номер письменно и 11 номера, 7 номера