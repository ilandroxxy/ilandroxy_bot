# region Домашка: ************************************************************

# endregion Домашка: ************************************************************


# region Урок: ******************************************************************

# Тип 25 №48446
# Маска числа — это последовательность цифр, в которой могут встречаться специальные символы «?» и «*».
# Символ «?» означает ровно одну произвольную цифру,
# символ «*» означает произвольную (в том числе пустую) последовательность цифр.
#
# Найдите все натуральные числа, не превышающие 10**10, которые соответствуют маске 1?493*41
# и при этом без остатка делятся на 2023. В ответе запишите все найденные числа в порядке возрастания.
'''
from fnmatch import *
for x in range(2023, 10**10, 2023):  # и при этом без остатка делятся на 2023
    if fnmatch(str(x), '1?493*41'):  # которые соответствуют маске 1?493*41
        print(x)
'''
# Ответ:
# 1349341
# 1249338041
# 1549348941
# 1849359841


# № 12477 PRO100 ЕГЭ 29.12.23 (Уровень: Средний)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
#
# символ «?» означает ровно одну произвольную цифру;
# символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.

# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
#
# Среди натуральных чисел, не превышающих 10**7, найдите все простые числа, соответствующие маске 3?1111*.
#
# В ответе запишите все найденные числа в порядке возрастания.
# Количество строк в таблице для ответа избыточно.
"""
import time
start = time.time()


from fnmatch import *


def prime(x):
    for j in range(2, x):
        if x % j == 0:
            return False  # число составное
    return True  # число простое


# Вариант 1, скорость: 4.36
'''
for x in range(10**7):
    if fnmatch(str(x), '3?1111*'):
        if prime(x):
            print(x)
'''


# Вариант 2, скорость: больше 10 минут..

for x in range(10**7):
    if prime(x):
        if fnmatch(str(x), '3?1111*'):
            print(x)


end = time.time()
print(end - start)
"""
"""
from fnmatch import *

def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


for x in range(10**7):
    if fnmatch(str(x), '3?1111*'):
        if len(divisors(x)) == 2:
            print(x)
"""
# Ответ:
# 311111
# 361111
# 3011117
# 3011119
# 3311117
# 3611119
# 3811117
# 3911111


"""
import time
start = time.time()

'''
def divisors(x):  
    div = []
    for j in range(1, x+1):
        if x % j == 0:
            div.append(j)
    return div

print(divisors(100_000_000))  # Скорость выполнения вычислений: 2.88
'''


def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


print(divisors(100_000_000))  # Скорость выполнения вычислений: 0.0003

end = time.time()
print(end - start)
"""

# Тип 25 №27852
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [185311; 185330],
# числа, имеющие ровно четыре различных натуральных делителя. Для каждого найденного числа
# запишите эти четыре делителя в четыре соседних столбца на экране с новой строки.
# Делители в строке должны следовать в порядке возрастания.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


for x in range(185311, 185330+1):
    d = divisors(x)
    if len(d) == 4:
        print(*d)
'''
# Ответ:
# 1 2 92657 185314
# 1 47 3943 185321
# 1 241 769 185329


# Тип 25 №27854
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку
# [110203; 110245], числа, имеющие ровно четыре различных чётных натуральных делителя
# (при этом количество нечётных делителей может быть любым).
# Для каждого найденного числа запишите эти четыре делителя в четыре
# соседних столбца на экране с новой строки.
# Делители в строке должны следовать в порядке возрастания.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set([x for x in div if x % 2 == 0]))


for x in range(110203, 110245+1):
    d = divisors(x)
    if len(d) == 4:
        print(*d)
'''
# Ответ:
# 2 4 55102 110204
# 2 14 15746 110222
# 2 6 36742 110226
# 2 22 10022 110242


# Тип 25 №33527
# Найдите все натуральные числа, принадлежащие отрезку [101000000; 102000000],
# у которых ровно три различных чётных делителя (при этом количество нечётных делителей может быть любым).
# В ответе перечислите найденные числа в порядке возрастания.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set([x for x in div if x % 2 == 0]))


for x in range(101000000, 102000000+1):
    d = divisors(x)
    if len(d) == 3:
        print(x)
'''
# Ответ:
# 101075762
# 101417282
# 101588258
# 101645282


# Тип 25 №33495
# Рассмотрим произвольное натуральное число, представим его всеми возможными способами в виде произведения
# двух натуральных чисел и найдём для каждого такого произведения разность сомножителей.
# Например, для числа 16 получим: 16 = 16*1 = 8*2 = 4*4, множество разностей содержит числа 15, 6 и 0.
# Найдите все натуральные числа, принадлежащие отрезку [2000000; 3000000],
# у которых составленное описанным способом множество разностей будет содержать не меньше трёх элементов,
# не превышающих 115. В ответе перечислите найденные числа в порядке возрастания.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            if (x // j) - j <= 115:
                div.append((x // j) - j)
    return sorted(set(div))


for x in range(2000000, 3000000+1):
    d = divisors(x)
    if len(d) >= 3:
        print(x)
'''
# Ответ:
# 2053440
# 2098080
# 2328480
# 2638944


# Тип 25 №36038
# Пусть M — сумма минимального и максимального натуральных делителей целого числа, не считая единицы и самого числа.
# Если таких делителей у числа нет, то считаем значение M равным нулю.
#
# Напишите программу, которая перебирает целые числа, большие 452021, в порядке возрастания и ищет среди них такие,
# для которых значение M при делении на 7 даёт в остатке 3.
# Вывести первые 5 найденных чисел и соответствующие им значения M.
#
# Формат вывода: для каждого из 5 таких найденных чисел в отдельной
# строке сначала выводится само число, затем — значение М.
# Строки выводятся в порядке возрастания найденных чисел.
'''
def divisors(x):
    div = []
    for j in range(2, int(x**0.5)+1):  # не считая единицы и самого числа.
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


k = 0
for x in range(452021+1, 100000000):
    d = divisors(x)
    if len(d) >= 2:
        M = d[0] + d[-1]  # M — сумма минимального и максимального натуральных делителей целого числа
        if M % 7 == 3:
            print(x, M)
            k += 1
            if k == 5:
                break
'''
# 452025 150678
# 452029 23810
# 452034 226019
# 452048 226026
# 452062 226033


# Тип 25 №28121
# Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [2422000; 2422080], простые числа.
# Выведите все найденные простые числа в порядке возрастания, слева от каждого числа выведите его номер по порядку,
# считая, что первое найденное число имеет номер «1», второе— «2», и т.д.
'''
def divisors(x):
    div = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            div.append(j)
            div.append(x // j)
    return sorted(set(div))


k = 1
for x in range(2422000, 2422080+1):
    if len(divisors(x)) == 2:
        print(k, x)
        k += 1
'''
# Ответ:
# 1 2422027
# 2 2422033
# 3 2422037
# 4 2422073


# endregion Урок: ***************************************************************


# Сева = [2.1, 6.1, 5.1, 8.1, 12.1, 14.1, 15.1, 16.1, 23.1, 25.1]
# КЕГЭ  = []
# на следующем уроке:
