# region Домашка:  ******************************************************************************

#1 35976
"""
print("x y z w F")
for x in range(2):
    for y in range(2):
        for z in range(2):
            for w in range(2):
                F = (((x and (not(y)) == (z or (not(w))) <= (x and z)):
                if F == False:
                    print(x, y, z, w, F)
"""
#Ответ: yzwx

#2 33472
"""
print("x y z w F")
for x in range(2):
    for y in range(2):
        for z in range(2):
            for w in range(2):
                F = (w < x) and ((y < z) == (x < y))
                print(x, y, z, w, F)
"""
#Ответ: xzyw

#3 15970
"""
print("x y z w F")
for x in range(2):
    for y in range(2):
        for z in range(2):
            for w in range(2):
                F = (x and (not(y))) or (y == z ) or w
                if F == False:
                    print(x,y,z,w,F)
"""
#Ответ: yxwz


# endregion Домашка: ******************************************************************************



# region Урок:  ******************************************************************************


# Тип 6 № 47314
'''
# В начальный момент Черепаха находится в начале координат, её голова направлена вдоль положительного направления оси ординат, хвост опущен.
# Черепахе был дан для исполнения следующий алгоритм:
# Повтори 5 [Вперёд 7 Направо 90 Вперёд 4 Направо 90]
#
# Определите количество точек с целочисленными координатами, лежащих внутри или на границе области, которую ограничивает заданная алгоритмом линия.


import turtle as t  # подключение библиотеки
t.left(90)  # поворот головы влево на 90 градусов
l = 50  # переменная хранящая масштаб
t.speed(10)  #  Ускоряем отрисовку пера

for _ in range(5):  # отрисовываем алгоритм
    t.forward(7*l)
    t.right(90)
    t.forward(4*l)  # вносим свой масштаб отрисовки через переменную l
    t.right(90)

t.pu()  # поднимем перо, чтобы не делать лишних рисований при передвижении пера
t.color('red')  # меняем цвет, чтобы точки не сливались с фигурой
for x in range(0, 5):
    for y in range(0, 8):
        t.goto(x * l, y * l)  # перебираем точки в той четверти, где лежит фигура с сохранением масштаба
        t.dot(2)  # отрисовываем точку с толщиной линии

t.done()  # команда помогает зафиксировать окно вывода
'''
# Ответ: 40 потому что точки на линии тоже считали (по условию)


# Тип 6 № 47406
'''
# В начальный момент Черепаха находится в начале координат, её голова направлена вдоль положительного направления оси ординат, хвост опущен.
# Черепахе был дан для исполнения следующий алгоритм:
# Повтори 4 [Вперёд 12 Направо 90]
# Повтори 3 [Вперёд 12 Направо 120]
#
# Определите, сколько точек с целочисленными координатами будут находиться внутри области, ограниченной линией, заданной данным алгоритмом: Повтори 4 [Вперёд 12 Направо 90]
# и находиться вне области, ограниченной линией, заданной данным алгоритмом: Повтори 3 [Вперёд 12 Направо 120].
# Точки на линии учитывать не следует.

# Вариант 1
import turtle as t
t.left(90)
l = 30
t.speed(10)

for _ in range(4):
    t.forward(12*l)
    t.right(90)

t.color('blue')
for _ in range(3):
    t.forward(12*l)
    t.right(120)

t.pu()
t.color('red')
for x in range(0, 13):
    for y in range(0, 13):
        t.goto(x * l, y * l)
        t.dot(3)

t.done()
'''

# Вариант 2
'''
import turtle as t
t.left(90)
l = 30
t.speed(10)
t.color('red')

t.begin_fill()
for _ in range(4):
    t.forward(12*l)
    t.right(90)
t.end_fill()

t.begin_fill()
for _ in range(3):
    t.forward(12*l)
    t.right(120)
t.end_fill()

count = 0
canvas = t.getcanvas()
for x in range(-100*l, 100*l, l):
    for y in range(-100 * l, 100 * l, l):
        z = canvas.find_overlapping(x, y, x, y)
        if len(z) == 1 and z[0] == 5:
            count += 1
print(count)

t.done()
'''
# Ответ: 65.

# Списоки list()
'''
M = []  # Создание пустого списка
M = list()  # Создание пустого списка

# Список list() это типа данных коллекций - хранящий в себе упорядоченные элементы.
# У каждого элемента списка есть свой порядковый номер - индекс (индексы начинаются с нуля)
# Элементы списка можно не только брать через индексы, но и изменять/удалять

# i                 0  1  2
M = [1, 2, 3, '5', [1, 2, 3]]  # Список может содержать элементы разных типов, в том числе и другой список/коллекцию
# i  0  1  2   3      4
# i -5 -4 -3  -2     -1

print(M[0], M[-1])  # получаем первый и последний элемент списка

M[2] = '*'
print(M, M[2])

print(M[4][1])  # 2
M.clear()

M = [2, 3, 4, 5]
print(len(M))  # функция len() возвращает длину списка(коллекций/строк) - то есть кол-во элементов в нем

for i in range(0, len(M)):  # [0, 5)  - пробегаем элементы списка через их индексы
    print(M[i], end=' ')
print()

for x in M:  # пробегаем список напрямую через значение его элементов
    print(x, end=' ')  
print()

print(M)  # ТОЛЬКО через индексы можем менять элементы списка
for i in range(0, len(M)):
    M[i] = M[i] ** 2
print(M)
'''

# Функции списков
'''
M = [1, 2, 2, 3, 4, 4]
print(len(M))  # длина
print(sum(M))  # сумма элементов
print(max(M))  # максимальный элемент
print(min(M))  # минимальный элемент
print('M:', M)

A = set(M)  # поменяли тип данных на множество - тем самым отбросили повторяющиеся элементы
print('A:', A, len(A))  # вывели кол-во неповторяющихся цифр

B = {}  # пустой словарь dict()
for x in M:
    B[x] = M.count(x)
print('B:', B)  # найдите чаще всего встречаемую цифру в записи
'''

# Методы списков
'''
M = [1, 2, 2, 3, 4, 4]
M.append(0)
M.append(0)
M.append(2)  # добавляем элемент в конец списка
print(M)

M.sort()  # Отсортировали список по возрастанию
print(M)

M.reverse()  # развернули список (по факту получили по убыванию)
print(M)

M.reverse()
M.append(8)  # добавили элемент слева
M.reverse()
print(M)

print(M.count(2))  # кол-во элементов в списке

print(M.index(2))  # выводит индекс первого найденного элемента

i = M.index(1)
x = M.pop(i)  # забрал из списка элемент по индексу i
print(M, x)

a = 4
b = a

B = M  # не создает копии элемента, а создает некую связь
A = M.copy()  # настоящее создание копии массива
print(B, M, A)
M.clear()  # просто опустошили список
print(B, M, A) 
'''

# Тип 14 № 39243
"""
# Значение выражения 4**34 + 5*4**22 + 4**13 + 2*4**9 + 82 записали в системе счисления с основанием 16.
# Сколько разных цифр встречается в этой записи?
x = 4**34 + 5*4**22 + 4**13 + 2*4**9 + 82
M = []
while x > 0:
    M.append(x % 16)
    x //= 16
M.reverse()
print(M)

A = set(M)
print(A, len(A))
"""
# Ответ: 6


# endregion Урок:  ******************************************************************************


# todo: Ислам = [2, 6], на следующем уроке: Разбираем 14 номер (второго типа) и списочные выражения
